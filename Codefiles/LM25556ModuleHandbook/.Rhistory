labs(x = "Predictor (X)", y = "Response (Y)") +
theme(
legend.position = "none", # Hide the legend as it's redundant
panel.grid.minor = element_blank(),
panel.grid.major = element_line(linetype = "dashed", color = "grey85"),
strip.background = element_blank(), # Remove facet title background
strip.text = element_text(face = "bold", size = 14), # Style facet titles
axis.title = element_text(size = 12)
)
library(tidyverse)
# --- SIMULATION PARAMETERS: Define the rules for our data ---
# Use set.seed() to make our "random" data reproducible.
set.seed(42)
# Define the basic parameters for the experiment
n_groups <- 5      # Number of groups (e.g., 5 different individuals)
n_obs_per_group <- 11 # Number of observations per group (from X=0 to X=10)
x <- 0:10          # The predictor variable values
# Define the "fixed" or population-level effects (the thick black line)
pop_intercept <- 2.0  # The overall average intercept
pop_slope <- 0.5     # The overall average slope
residual_sd <- 0.8   # The random "noise" for each individual point
# Define the variance of the "random" effects
intercept_sd <- 2.0  # How much the group intercepts vary around the mean
slope_sd <- 0.8      # How much the group slopes vary (increased for more visual difference)
# --- DATA GENERATION: Create the two datasets ---
# First, generate the unique random effects for each of the 5 groups
random_intercepts <- rnorm(n_groups, mean = 0, sd = intercept_sd)
random_slopes <- rnorm(n_groups, mean = 0, sd = slope_sd)
# Generate the "Random Intercepts" dataset
data_ri <- map_df(1:n_groups, ~{
tibble(
group = as.character(.x),
x = x,
# Formula: y = (overall_intercept + group_specific_intercept) + (overall_slope * x) + error
y = (pop_intercept + random_intercepts[.x]) + (pop_slope * x) + rnorm(n_obs_per_group, 0, residual_sd),
model_type = "Random Intercepts Model"
)
})
# Generate the "Random Slopes and Intercepts" dataset
data_rs <- map_df(1:n_groups, ~{
tibble(
group = as.character(.x),
x = x,
# Formula: y = (overall_intercept + group_specific_intercept) + (overall_slope + group_specific_slope) * x + error
y = (pop_intercept + random_intercepts[.x]) + (pop_slope + random_slopes[.x]) * x + rnorm(n_obs_per_group, 0, residual_sd),
model_type = "Random Slopes + Intercepts Model"
)
})
# --- PLOTTING: Combine data and create the final figure ---
# Combine both datasets into a single data frame for plotting
full_data <- bind_rows(data_ri, data_rs)
# Create a small data frame to hold the annotation text and arrow coordinates
annotations <- tibble(
model_type = c("Random Intercepts Model", "Random Slopes + Intercepts Model"),
label = c("Groups differ\nin baseline (intercept)", "Groups differ in\nboth baseline & slope"),
x_arrow = c(0, 7),
y_arrow = c(10.5, 10.5),
x_text = c(0.5, 3),
y_text = c(11, 11),
x_arrow_end = c(0, 7),
y_arrow_end = c(5, 5)
)
# Create the final plot using ggplot2
ggplot(full_data, aes(x = x, y = y, color = group, group = group)) +
# Add the individual group lines (dashed and now fully opaque with alpha=1)
geom_line(linetype = "dashed", alpha = 1) +
# Add the individual data points (also fully opaque)
geom_point(alpha = 1) +
# Add the overall "fixed effect" or population-level line
geom_abline(intercept = pop_intercept, slope = pop_slope,
color = "black", linewidth = 1.5) +
# Add the arrows using the annotations data frame
geom_segment(
data = annotations,
aes(x = x_arrow, y = y_arrow, xend = x_arrow_end, yend = y_arrow_end),
arrow = arrow(length = unit(0.3, "cm")),
inherit.aes = FALSE # This prevents ggplot from trying to color the arrows
) +
# Add the text labels using the annotations data frame
geom_text(
data = annotations,
aes(x = x_text, y = y_text, label = label),
hjust = 0, vjust = 0,
inherit.aes = FALSE
) +
# Use facet_wrap to create the two side-by-side plots
facet_wrap(~ model_type) +
# --- Final aesthetic touches ---
scale_color_brewer(palette = "Set2") +
theme_bw() +
labs(x = "Predictor (X)", y = "Response (Y)") +
theme(
legend.position = "none", # Hide the legend as it's redundant
panel.grid.minor = element_blank(),
panel.grid.major = element_line(linetype = "dashed", color = "grey85"),
strip.background = element_blank(), # Remove facet title background
strip.text = element_text(face = "bold", size = 14), # Style facet titles
axis.title = element_text(size = 12)
)
library(tidyverse)
# --- SIMULATION PARAMETERS: Define the rules for our data ---
# Use set.seed() to make our "random" data reproducible.
set.seed(42)
# Define the basic parameters for the experiment
n_groups <- 5      # Number of groups (e.g., 5 different individuals)
n_obs_per_group <- 11 # Number of observations per group (from X=0 to X=10)
x <- 0:10          # The predictor variable values
# Define the "fixed" or population-level effects (the thick black line)
pop_intercept <- 2.0  # The overall average intercept
pop_slope <- 0.5     # The overall average slope
residual_sd <- 0.8   # The random "noise" for each individual point
# Define the variance of the "random" effects
intercept_sd <- 2.0  # How much the group intercepts vary around the mean
slope_sd <- 0.8      # How much the group slopes vary (increased for more visual difference)
# --- DATA GENERATION: Create the two datasets ---
# First, generate the unique random effects for each of the 5 groups
random_intercepts <- rnorm(n_groups, mean = 0, sd = intercept_sd)
random_slopes <- rnorm(n_groups, mean = 0, sd = slope_sd)
# Generate the "Random Intercepts" dataset
data_ri <- map_df(1:n_groups, ~{
tibble(
group = as.character(.x),
x = x,
# Formula: y = (overall_intercept + group_specific_intercept) + (overall_slope * x) + error
y = (pop_intercept + random_intercepts[.x]) + (pop_slope * x) + rnorm(n_obs_per_group, 0, residual_sd),
model_type = "Random Intercepts Model"
)
})
# Generate the "Random Slopes and Intercepts" dataset
data_rs <- map_df(1:n_groups, ~{
tibble(
group = as.character(.x),
x = x,
# Formula: y = (overall_intercept + group_specific_intercept) + (overall_slope + group_specific_slope) * x + error
y = (pop_intercept + random_intercepts[.x]) + (pop_slope + random_slopes[.x]) * x + rnorm(n_obs_per_group, 0, residual_sd),
model_type = "Random Slopes + Intercepts Model"
)
})
# --- PLOTTING: Combine data and create the final figure ---
# Combine both datasets into a single data frame for plotting
full_data <- bind_rows(data_ri, data_rs)
# Create a small data frame to hold the annotation text and arrow coordinates
annotations <- tibble(
model_type = c("Random Intercepts Model", "Random Slopes + Intercepts Model"),
label = c("Groups differ\nin baseline (intercept)", "Groups differ in\nboth baseline & slope"),
x_arrow = c(0, 7),
y_arrow = c(10.5, 10.5),
x_text = c(0.5, 3),
y_text = c(11, 11),
x_arrow_end = c(0, 7),
y_arrow_end = c(5, 5)
)
# Create the final plot using ggplot2
ggplot(full_data, aes(x = x, y = y, color = group, group = group)) +
# Add the individual group lines (dashed and now fully opaque with alpha=1)
geom_line(linetype = "dashed", alpha = 1) +
# Add the individual data points (also fully opaque)
geom_point(alpha = 1) +
# Add the overall "fixed effect" or population-level line
geom_abline(intercept = pop_intercept, slope = pop_slope,
color = "black", linewidth = 1.5) +
# Add the arrows using the annotations data frame
geom_segment(
data = annotations,
aes(x = x_arrow, y = y_arrow, xend = x_arrow_end, yend = y_arrow_end),
arrow = arrow(length = unit(0.3, "cm")),
inherit.aes = FALSE # This prevents ggplot from trying to color the arrows
) +
# Add the text labels using the annotations data frame
geom_text(
data = annotations,
aes(x = x_text, y = y_text, label = label),
hjust = 0, vjust = 0,
inherit.aes = FALSE
) +
# Use facet_wrap to create the two side-by-side plots
facet_wrap(~ model_type) +
# --- Final aesthetic touches ---
scale_color_brewer(palette = "Set2") +
theme_bw() +
labs(x = "Predictor (X)", y = "Response (Y)") +
theme(
legend.position = "none", # Hide the legend as it's redundant
panel.grid.minor = element_blank(),
panel.grid.major = element_line(linetype = "dashed", color = "grey85"),
strip.background = element_blank(), # Remove facet title background
strip.text = element_text(face = "bold", size = 14), # Style facet titles
axis.title = element_text(size = 12)
)
library(tidyverse)
# --- SIMULATION PARAMETERS: Define the rules for our data ---
# Use set.seed() to make our "random" data reproducible.
set.seed(42)
# Define the basic parameters for the experiment
n_groups <- 5      # Number of groups (e.g., 5 different individuals)
n_obs_per_group <- 11 # Number of observations per group (from X=0 to X=10)
x <- 0:10          # The predictor variable values
# Define the "fixed" or population-level effects (the thick black line)
pop_intercept <- 2.0  # The overall average intercept
pop_slope <- 0.5     # The overall average slope
residual_sd <- 0.8   # The random "noise" for each individual point
# Define the variance of the "random" effects
intercept_sd <- 2.0  # How much the group intercepts vary around the mean
slope_sd <- 0.8      # How much the group slopes vary (increased for more visual difference)
# --- DATA GENERATION: Create the two datasets ---
# First, generate the unique random effects for each of the 5 groups
random_intercepts <- rnorm(n_groups, mean = 0, sd = intercept_sd)
random_slopes <- rnorm(n_groups, mean = 0, sd = slope_sd)
# Generate the "Random Intercepts" dataset
data_ri <- map_df(1:n_groups, ~{
tibble(
group = as.character(.x),
x = x,
# Formula: y = (overall_intercept + group_specific_intercept) + (overall_slope * x) + error
y = (pop_intercept + random_intercepts[.x]) + (pop_slope * x) + rnorm(n_obs_per_group, 0, residual_sd),
model_type = "Random Intercepts Model"
)
})
# Generate the "Random Slopes and Intercepts" dataset
data_rs <- map_df(1:n_groups, ~{
tibble(
group = as.character(.x),
x = x,
# Formula: y = (overall_intercept + group_specific_intercept) + (overall_slope + group_specific_slope) * x + error
y = (pop_intercept + random_intercepts[.x]) + (pop_slope + random_slopes[.x]) * x + rnorm(n_obs_per_group, 0, residual_sd),
model_type = "Random Slopes + Intercepts Model"
)
})
# --- PLOTTING: Combine data and create the final figure ---
# Combine both datasets into a single data frame for plotting
full_data <- bind_rows(data_ri, data_rs)
# Create a small data frame to hold the annotation text and arrow coordinates
annotations <- tibble(
model_type = c("Random Intercepts Model", "Random Slopes + Intercepts Model"),
label = c("Groups differ\nin baseline (intercept)", "Groups differ in\nboth baseline & slope"),
x_arrow = c(0, 7),
y_arrow = c(10.5, 10.5),
x_text = c(0.5, 3),
y_text = c(11, 11),
x_arrow_end = c(0, 7),
y_arrow_end = c(5, 5)
)
# Create the final plot using ggplot2
ggplot(full_data, aes(x = x, y = y, color = group, group = group)) +
# Add the individual group lines (dashed and now fully opaque with alpha=1)
geom_line(linetype = "dashed", alpha = 1) +
# Add the individual data points (also fully opaque)
geom_point(alpha = 1) +
# Add the overall "fixed effect" or population-level line
geom_abline(intercept = pop_intercept, slope = pop_slope,
color = "black", linewidth = 1.5) +
# Add the arrows using the annotations data frame
geom_segment(
data = annotations,
aes(x = x_arrow, y = y_arrow, xend = x_arrow_end, yend = y_arrow_end),
arrow = arrow(length = unit(0.3, "cm")),
inherit.aes = FALSE # This prevents ggplot from trying to color the arrows
) +
# Add the text labels using the annotations data frame
geom_text(
data = annotations,
aes(x = x_text, y = y_text, label = label),
hjust = 0, vjust = 0,
inherit.aes = FALSE
) +
# Use facet_wrap to create the two side-by-side plots
facet_wrap(~ model_type) +
# --- Final aesthetic touches ---
scale_color_brewer(palette = "Set2") +
theme_bw() +
labs(x = "Predictor (X)", y = "Response (Y)") +
theme(
legend.position = "none", # Hide the legend as it's redundant
panel.grid.minor = element_blank(),
panel.grid.major = element_line(linetype = "dashed", color = "grey85"),
strip.background = element_blank(), # Remove facet title background
strip.text = element_text(face = "bold", size = 14), # Style facet titles
axis.title = element_text(size = 12)
)
# List of packages
packages <- c("tidyverse", "ggfortify", "performance", "car", "skimr", "gridExtra", "broom",
"ggeffects","MASS","MuMIn", "lme4","lmer")
# Load all packages and install the packages we have no previously installed on the system
lapply(packages, library, character.only = TRUE)
# List of packages
packages <- c("tidyverse", "ggfortify", "performance", "car", "skimr", "gridExtra", "broom",
"ggeffects","MASS","MuMIn", "lme4","lmerTest")
# Load all packages and install the packages we have no previously installed on the system
lapply(packages, library, character.only = TRUE)
# List of packages
packages <- c("tidyverse", "ggfortify", "performance", "car", "skimr", "gridExtra", "broom",
"ggeffects","MASS","MuMIn", "lme4")
# Load all packages and install the packages we have no previously installed on the system
lapply(packages, library, character.only = TRUE)
# List of packages
packages <- c("tidyverse", "ggfortify", "performance", "car", "skimr", "gridExtra", "broom",
"ggeffects","MASS","MuMIn", "lme4","glmmTMB")
# Load all packages and install the packages we have no previously installed on the system
lapply(packages, library, character.only = TRUE)
# List of packages
packages <- c("tidyverse", "ggfortify", "performance", "car", "skimr", "gridExtra", "broom",
"ggeffects","MASS","MuMIn", "lme4","glmmTMB", "DHARMa")
# Load all packages and install the packages we have no previously installed on the system
lapply(packages, library, character.only = TRUE)
citation("glmmTMB")
citation("DHARMa")
#| label: mixed_model
#| echo: false
#| fig-cap: "**Mixed model example**"
knitr::include_graphics("images/mixed_model_example.png")
#| label: mixed_model
#| echo: false
#| fig-cap: "**Mixed model example**"
knitr::include_graphics("images/mixed_model_example.png")
#| label: mixed_model
#| echo: false
#| fig-cap: "**Mixed model example**"
knitr::include_graphics("images/mixed_model_example.png")
#| label: mixed_model
#| echo: false
#| fig-cap: "**Mixed model example**"
knitr::include_graphics("images/mixed_model_example.png")
#| label: mixed_model
#| echo: false
#| fig-cap: "**Mixed model example**"
knitr::include_graphics("images/mixed_models_examples.png")
library(tidyverse)
# --- SIMULATION PARAMETERS: Define the rules for our data ---
# Use set.seed() to make our "random" data reproducible.
set.seed(42)
# Define the basic parameters for the experiment
n_groups <- 5      # Number of groups (e.g., 5 different individuals)
n_obs_per_group <- 11 # Number of observations per group (from X=0 to X=10)
x <- 0:10          # The predictor variable values
# Define the "fixed" or population-level effects (the thick black line)
pop_intercept <- 2.0  # The overall average intercept
pop_slope <- 0.5     # The overall average slope
residual_sd <- 0.8   # The random "noise" for each individual point
# Define the variance of the "random" effects
intercept_sd <- 2.0  # How much the group intercepts vary around the mean
slope_sd <- 0.8      # How much the group slopes vary (increased for more visual difference)
# --- DATA GENERATION: Create the two datasets ---
# First, generate the unique random effects for each of the 5 groups
random_intercepts <- rnorm(n_groups, mean = 0, sd = intercept_sd)
random_slopes <- rnorm(n_groups, mean = 0, sd = slope_sd)
# Generate the "Random Intercepts" dataset
data_ri <- map_df(1:n_groups, ~{
tibble(
group = as.character(.x),
x = x,
# Formula: y = (overall_intercept + group_specific_intercept) + (overall_slope * x) + error
y = (pop_intercept + random_intercepts[.x]) + (pop_slope * x) + rnorm(n_obs_per_group, 0, residual_sd),
model_type = "Random Intercepts Model"
)
})
# Generate the "Random Slopes and Intercepts" dataset
data_rs <- map_df(1:n_groups, ~{
tibble(
group = as.character(.x),
x = x,
# Formula: y = (overall_intercept + group_specific_intercept) + (overall_slope + group_specific_slope) * x + error
y = (pop_intercept + random_intercepts[.x]) + (pop_slope + random_slopes[.x]) * x + rnorm(n_obs_per_group, 0, residual_sd),
model_type = "Random Slopes + Intercepts Model"
)
})
# --- PLOTTING: Combine data and create the final figure ---
# Combine both datasets into a single data frame for plotting
full_data <- bind_rows(data_ri, data_rs)
# Create a small data frame to hold the annotation text and arrow coordinates
annotations <- tibble(
model_type = c("Random Intercepts Model", "Random Slopes + Intercepts Model"),
label = c("Groups differ\nin baseline (intercept)", "Groups differ in\nboth baseline & slope"),
x_arrow = c(0, 7),
y_arrow = c(10.5, 10.5),
x_text = c(0.5, 3),
y_text = c(11, 11),
x_arrow_end = c(0, 7),
y_arrow_end = c(5, 5)
)
# Create the final plot using ggplot2
ggplot(full_data, aes(x = x, y = y, color = group, group = group)) +
# Add the individual group lines (dashed and now fully opaque with alpha=1)
geom_line(linetype = "dashed", alpha = 1) +
# Add the individual data points (also fully opaque)
geom_point(alpha = 1) +
# Add the overall "fixed effect" or population-level line
geom_abline(intercept = pop_intercept, slope = pop_slope,
color = "black", linewidth = 1.5) +
# Add the arrows using the annotations data frame
geom_segment(
data = annotations,
aes(x = x_arrow, y = y_arrow, xend = x_arrow_end, yend = y_arrow_end),
arrow = arrow(length = unit(0.3, "cm")),
inherit.aes = FALSE # This prevents ggplot from trying to color the arrows
) +
# Add the text labels using the annotations data frame
geom_text(
data = annotations,
aes(x = x_text, y = y_text, label = label),
hjust = 0, vjust = 0,
inherit.aes = FALSE
) +
# Use facet_wrap to create the two side-by-side plots
facet_wrap(~ model_type) +
# --- Final aesthetic touches ---
scale_color_brewer(palette = "Set2") +
theme_bw() +
labs(x = "Predictor (X)", y = "Response (Y)") +
theme(
legend.position = "none", # Hide the legend as it's redundant
panel.grid.minor = element_blank(),
panel.grid.major = element_line(linetype = "dashed", color = "grey85"),
strip.background = element_blank(), # Remove facet title background
strip.text = element_text(face = "bold", size = 14), # Style facet titles
axis.title = element_text(size = 12)
)
# --- SIMULATION PARAMETERS: Define the rules for our data ---
# Use set.seed() to make our "random" data reproducible.
set.seed(42)
# Define the basic parameters for the experiment
n_groups <- 5      # Number of groups (e.g., 5 different individuals)
n_obs_per_group <- 11 # Number of observations per group (from X=0 to X=10)
x <- 0:10          # The predictor variable values
# Define the "fixed" or population-level effects (the thick black line)
pop_intercept <- 2.0  # The overall average intercept
pop_slope <- 0.5     # The overall average slope
residual_sd <- 0.8   # The random "noise" for each individual point
# Define the variance of the "random" effects
intercept_sd <- 2.0  # How much the group intercepts vary around the mean
slope_sd <- 0.8      # How much the group slopes vary (increased for more visual difference)
# --- DATA GENERATION: Create the two datasets ---
# First, generate the unique random effects for each of the 5 groups
random_intercepts <- rnorm(n_groups, mean = 0, sd = intercept_sd)
random_slopes <- rnorm(n_groups, mean = 0, sd = slope_sd)
# Generate the "Random Intercepts" dataset
data_ri <- map_df(1:n_groups, ~{
tibble(
group = as.character(.x),
x = x,
# Formula: y = (overall_intercept + group_specific_intercept) + (overall_slope * x) + error
y = (pop_intercept + random_intercepts[.x]) + (pop_slope * x) + rnorm(n_obs_per_group, 0, residual_sd),
model_type = "Random Intercepts Model"
)
})
# Generate the "Random Slopes and Intercepts" dataset
data_rs <- map_df(1:n_groups, ~{
tibble(
group = as.character(.x),
x = x,
# Formula: y = (overall_intercept + group_specific_intercept) + (overall_slope + group_specific_slope) * x + error
y = (pop_intercept + random_intercepts[.x]) + (pop_slope + random_slopes[.x]) * x + rnorm(n_obs_per_group, 0, residual_sd),
model_type = "Random Slopes + Intercepts Model"
)
})
# --- PLOTTING: Combine data and create the final figure ---
# Combine both datasets into a single data frame for plotting
full_data <- bind_rows(data_ri, data_rs)
# Create a small data frame to hold the annotation text and arrow coordinates
annotations <- tibble(
model_type = c("Random Intercepts Model", "Random Slopes + Intercepts Model"),
label = c("Groups differ\nin baseline (intercept)", "Groups differ in\nboth baseline & slope"),
x_arrow = c(0, 7),
y_arrow = c(10.5, 10.5),
x_text = c(0.5, 3),
y_text = c(11, 11),
x_arrow_end = c(0, 7),
y_arrow_end = c(5, 5)
)
# Create the final plot using ggplot2
ggplot(full_data, aes(x = x, y = y, color = group, group = group)) +
# Add the individual group lines (dashed and now fully opaque with alpha=1)
geom_line(linetype = "dashed", alpha = 1) +
# Add the individual data points (also fully opaque)
geom_point(alpha = 1) +
# Add the overall "fixed effect" or population-level line
geom_abline(intercept = pop_intercept, slope = pop_slope,
color = "black", linewidth = 1.5) +
# Add the arrows using the annotations data frame
geom_segment(
data = annotations,
aes(x = x_arrow, y = y_arrow, xend = x_arrow_end, yend = y_arrow_end),
arrow = arrow(length = unit(0.3, "cm")),
inherit.aes = FALSE # This prevents ggplot from trying to color the arrows
) +
# Add the text labels using the annotations data frame
geom_text(
data = annotations,
aes(x = x_text, y = y_text, label = label),
hjust = 0, vjust = 0,
inherit.aes = FALSE
) +
# Use facet_wrap to create the two side-by-side plots
facet_wrap(~ model_type) +
# --- Final aesthetic touches ---
scale_color_brewer(palette = "Set2") +
theme_bw() +
labs(x = "Predictor (X)", y = "Response (Y)") +
theme(
legend.position = "none", # Hide the legend as it's redundant
panel.grid.minor = element_blank(),
panel.grid.major = element_line(linetype = "dashed", color = "grey85"),
strip.background = element_blank(), # Remove facet title background
strip.text = element_text(face = "bold", size = 14), # Style facet titles
axis.title = element_text(size = 12)
)
#| label: mixed_model
#| echo: false
#| fig-cap: ""
knitr::include_graphics("images/mixed_models_examples.png")
#| label: mixed_model
#| echo: false
knitr::include_graphics("images/mixed_models_examples.png")
