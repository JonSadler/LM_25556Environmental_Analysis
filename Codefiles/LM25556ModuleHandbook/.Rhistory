library(car)
library(ggsignif) # new library you'll need to install it.
library(dplyr)
library(tidyr)
# Load data
pred <- read.csv("~/Documents/GitHub/Teaching/LM_25556Environmental_Analysis/Data/fish_pred.csv")
glimpse(pred)
# change character fields to factors
pred$Bullhead <- as.factor(pred$Bullhead)
pred$Loach <- as.factor(pred$Loach)
glimpse(pred) # check it worked
table(pred$Bullhead, pred$Loach)
# Fine so we can go with 2 way ANOVA (as we have one response and two FACTORS)
# Note - the fish are either present or absent...
op <- par(mfrow = c(1, 2)) # 1 row , 2 columns for the images
boxplot(Density ~ Bullhead, col = "lightblue", data = pred, xlab = "Bullhead")
boxplot(Density ~ Loach, col = "lightblue", data = pred, xlab = "Loach")
par(op)
# Or in ggplot - need to transform the data to a long format to do this easily
pred_long <- pred %>% gather(species,treatment, 1:2)
glimpse(pred_long) # looks fine we'll flip new variables to factors as we're going to create error bars plots
pred_long <- pred_long %>% mutate(species = factor(species),treatment = factor(treatment)) # use glimpse(pred_long) to check it worked
ggplot(pred_long, aes(y=Density, x=species, fill=treatment)) + geom_boxplot() +
labs(x = "Fish species", y = "Prey Density", fill = "Treatment")
# Variances look okay and the pattern indicates that Loach reduce midge density but Bullheads don't.
qqnorm(pred$Density); qqline(pred$Density)
shapiro.test(pred$Density)
# Data are normally distributed....
# Homogeneity of variance
leveneTest(pred$Density ~ pred$Bullhead * pred$Loach) # No issues visible
#plot interaction
interaction.plot(pred$Bullhead, pred$Loach, pred$Density, col=c(2,3), xlab = "Predators", ylab = "Midge Density", trace.label = "")
# Run ANOVA
pred_aov <- aov(Density ~ Loach * Bullhead, data = pred)
# Look at the output
summary(pred_aov)
op <- par(mfrow = c(2, 2)) # set graphics device to plot four graphs in a 2 x 2 matrix
plot(pred_aov)
par(op)
plot(pred_aov, which=6)
pred_sum <- pred_long %>%
group_by(species,treatment) %>%
summarise(
n=n(),
mean=mean(Density),
sd=sd(Density)) %>%
mutate( se=sd/sqrt(n))  %>% # computes the standard error
mutate( ic=se * qt((1-0.05)/2 + .5, n-1)) # computes 95% CI
ggplot(pred_sum, aes(x=species, y=mean, fill=treatment)) +
geom_bar(position=position_dodge(), stat="identity", colour='black') +
geom_errorbar(aes(ymin=mean-2*se, ymax=mean+2*se), width=.2,position=position_dodge(.9)) +
labs(x = "Fish species", y = "Prey Density", fill = "Treatment") + theme_bw()
ggplot(pred_sum, aes(x=species, y=mean, fill=treatment)) +
geom_bar(position=position_dodge(), stat="identity", colour='black') +
geom_errorbar(aes(ymin=mean-ic, ymax=mean+ic),width=.2,position=position_dodge(.9)) +
theme_bw() + # remove default grey background
scale_fill_manual(values = c("grey90","grey50")) + # override colours for treatment making them grey and white bars
theme(axis.title = element_text(size = 12),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text.x  = element_text(size=10, colour="black"),
axis.text.y  = element_text(size=10, colour="black"),
plot.caption=element_text(hjust = 0)) +
labs(x = "Species", y = expression(Prey~Density~(m^2)), fill = "Treatment",
caption = "Figure 1. Species impacts on prey density in experiment enclosures.\nn = 10 per treatment group (total = 40) ** = p<0.01.\nError bars are 95 and 5% CIs.") +
# \n = new line in caption
# to add significant level use the annotate function. Check the aov call for sig levels
annotate("text", x=2, y=4.2, label= "**") +
annotate("text", x=1, y=4.2, label= "NS") + theme(
plot.caption = element_text(size = 12)
)
ggplot(pred_sum, aes(x=species, y=mean, fill=treatment)) +
geom_bar(position=position_dodge(), stat="identity", colour='black') +
geom_errorbar(aes(ymin=mean-ic, ymax=mean+ic),width=.2,position=position_dodge(.9)) +
theme_bw() + # remove default grey background
scale_fill_manual(values = c("grey90","grey50")) + # override colours for treatment making them grey and white bars
theme(axis.title = element_text(size = 12),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text.x  = element_text(size=10, colour="black"),
axis.text.y  = element_text(size=10, colour="black"),
plot.caption=element_text(hjust = 0)) +
labs(x = "Species", y = expression(Prey~Density~(m^2)), fill = "Treatment",
caption = "Figure 1. Species impacts on prey density in experiment enclosures.\nn = 10 per treatment group (total = 40) ** = p<0.01.\nError bars are 95 and 5% CIs.") +
# \n = new line in caption
# to add significant level use the annotate function. Check the aov call for sig levels
annotate("text", x=2, y=4.2, label= "**") +
annotate("text", x=1, y=4.2, label= "NS") + theme(
plot.caption = element_text(size = 12)
)
library(magick)
# Read the plots
image1 <- image_read("Penguins.png")
image2 <- image_read("fish.png")
# Read your two photographs
# !!! IMPORTANT: Replace these paths with the actual file paths to your photos !!!
photo1 <- image_read("canal.jpg")
photo2 <- image_read("turnstones.jpg")
# Prepare the top row
# Scale each photo to be 450 pixels wide, maintaining aspect ratio
# This creates a 450x450 square by cropping from the center of the image.
# This avoids distorting the image.
image1_scaled <- image_crop(image1, "800")
image2_scaled <- image_crop(image2, "800")
# This avoids distorting the image.
photo1_scaled <- image_crop(photo1, "800")
photo2_scaled <- image_crop(photo2, "800")
# Prepare the bottom row
# Combine the two images side-by-side into a single image strip
top_row <- image_append(c(image1_scaled, image2_scaled))
# Combine the two scaled photos side-by-side into a single image strip
bottom_row <- image_append(c(photo1_scaled, photo2_scaled))
# Combine the top and bottom rows
# Stack the main plot on top of the bottom row image strip
final_cover <- image_append(c(top_row, bottom_row), stack = TRUE)
# Save the final composite image
# Write the final result to the file you want for your book cover
image_write(final_cover, path = "my-cover.png", format = "png")
library(magick)
# Read the plots
image1 <- image_read("Penguins.png")
image2 <- image_read("fish.png")
# Read your two photographs
# !!! IMPORTANT: Replace these paths with the actual file paths to your photos !!!
photo1 <- image_read("canal.jpg")
photo2 <- image_read("turnstones.jpg")
# Prepare the top row
# Scale each photo to be 450 pixels wide, maintaining aspect ratio
# This creates a 450x450 square by cropping from the center of the image.
# This avoids distorting the image.
image1_scaled <- image_crop(image1, "400")
image2_scaled <- image_crop(image2, "400")
# This avoids distorting the image.
photo1_scaled <- image_crop(photo1, "400")
photo2_scaled <- image_crop(photo2, "400")
# Prepare the bottom row
# Combine the two images side-by-side into a single image strip
top_row <- image_append(c(image1_scaled, image2_scaled))
# Combine the two scaled photos side-by-side into a single image strip
bottom_row <- image_append(c(photo1_scaled, photo2_scaled))
# Combine the top and bottom rows
# Stack the main plot on top of the bottom row image strip
final_cover <- image_append(c(top_row, bottom_row), stack = TRUE)
# Save the final composite image
# Write the final result to the file you want for your book cover
image_write(final_cover, path = "my-cover.png", format = "png")
image1 <- image_read("Penguins.png")
image2 <- image_read("fish.png")
# Read your two photographs
# !!! IMPORTANT: Replace these paths with the actual file paths to your photos !!!
photo1 <- image_read("canal.jpg")
photo2 <- image_read("turnstones.jpg")
# Prepare the top row
# Scale each photo to be 450 pixels wide, maintaining aspect ratio
# This creates a 450x450 square by cropping from the center of the image.
# This avoids distorting the image.
image1_scaled <- image_crop(image1)
image2_scaled <- image_crop(image2)
# This avoids distorting the image.
photo1_scaled <- image_crop(photo1)
photo2_scaled <- image_crop(photo2)
# Prepare the bottom row
# Combine the two images side-by-side into a single image strip
top_row <- image_append(c(image1_scaled, image2_scaled))
# Combine the two scaled photos side-by-side into a single image strip
bottom_row <- image_append(c(photo1_scaled, photo2_scaled))
# Combine the top and bottom rows
# Stack the main plot on top of the bottom row image strip
final_cover <- image_append(c(top_row, bottom_row), stack = TRUE)
# Save the final composite image
# Write the final result to the file you want for your book cover
image_write(final_cover, path = "my-cover.png", format = "png")
plot(cars)
# Load libraries we need.
library(tidyverse)
library(car)
library(ggsignif) # new library you'll need to install it.
library(dplyr)
library(tidyr)
# Load data
pred <- read.csv("~/Documents/GitHub/Teaching/LM_25556Environmental_Analysis/Data/fish_pred.csv")
glimpse(pred)
# change character fields to factors
pred$Bullhead <- as.factor(pred$Bullhead)
pred$Loach <- as.factor(pred$Loach)
glimpse(pred) # check it worked
table(pred$Bullhead, pred$Loach)
# Fine so we can go with 2 way ANOVA (as we have one response and two FACTORS)
# Note - the fish are either present or absent...
op <- par(mfrow = c(1, 2)) # 1 row , 2 columns for the images
boxplot(Density ~ Bullhead, col = "lightblue", data = pred, xlab = "Bullhead")
boxplot(Density ~ Loach, col = "lightblue", data = pred, xlab = "Loach")
par(op)
# Or in ggplot - need to transform the data to a long format to do this easily
pred_long <- pred %>% gather(species,treatment, 1:2)
glimpse(pred_long) # looks fine we'll flip new variables to factors as we're going to create error bars plots
pred_long <- pred_long %>% mutate(species = factor(species),treatment = factor(treatment)) # use glimpse(pred_long) to check it worked
ggplot(pred_long, aes(y=Density, x=species, fill=treatment)) + geom_boxplot() +
labs(x = "Fish species", y = "Prey Density", fill = "Treatment")
# Variances look okay and the pattern indicates that Loach reduce midge density but Bullheads don't.
qqnorm(pred$Density); qqline(pred$Density)
shapiro.test(pred$Density)
# Data are normally distributed....
# Homogeneity of variance
leveneTest(pred$Density ~ pred$Bullhead * pred$Loach) # No issues visible
#plot interaction
interaction.plot(pred$Bullhead, pred$Loach, pred$Density, col=c(2,3), xlab = "Predators", ylab = "Midge Density", trace.label = "")
# Run ANOVA
pred_aov <- aov(Density ~ Loach * Bullhead, data = pred)
# Look at the output
summary(pred_aov)
op <- par(mfrow = c(2, 2)) # set graphics device to plot four graphs in a 2 x 2 matrix
plot(pred_aov)
par(op)
plot(pred_aov, which=6)
pred_sum <- pred_long %>%
group_by(species,treatment) %>%
summarise(
n=n(),
mean=mean(Density),
sd=sd(Density)) %>%
mutate( se=sd/sqrt(n))  %>% # computes the standard error
mutate( ic=se * qt((1-0.05)/2 + .5, n-1)) # computes 95% CI
ggplot(pred_sum, aes(x=species, y=mean, fill=treatment)) +
geom_bar(position=position_dodge(), stat="identity", colour='black') +
geom_errorbar(aes(ymin=mean-2*se, ymax=mean+2*se), width=.2,position=position_dodge(.9)) +
labs(x = "Fish species", y = "Prey Density", fill = "Treatment") + theme_bw()
ggplot(pred_sum, aes(x=species, y=mean, fill=treatment)) +
geom_bar(position=position_dodge(), stat="identity", colour='black') +
geom_errorbar(aes(ymin=mean-ic, ymax=mean+ic),width=.2,position=position_dodge(.9)) +
theme_bw() + # remove default grey background
scale_fill_manual(values = c("grey90","grey50")) + # override colours for treatment making them grey and white bars
theme(axis.title = element_text(size = 12),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text.x  = element_text(size=10, colour="black"),
axis.text.y  = element_text(size=10, colour="black"),
plot.caption=element_text(hjust = 0)) +
labs(x = "Species", y = expression(Prey~Density~(m^2)), fill = "Treatment",
caption = "Figure 1. Species impacts on prey density in experiment enclosures.\nn = 10 per treatment group (total = 40) ** = p<0.01.\nError bars are 95 and 5% CIs.") +
# \n = new line in caption
# to add significant level use the annotate function. Check the aov call for sig levels
annotate("text", x=2, y=4.2, label= "**") +
annotate("text", x=1, y=4.2, label= "NS") + theme(
plot.caption = element_text(size = 12)
)
# --- Load required libraries ---
library(ggplot2)
library(showtext) # For using custom fonts
install.packages("showtext")
# --- Load required libraries ---
library(ggplot2)
library(showtext) # For using custom fonts
# --- Setup a clean, modern font from Google Fonts ---
# This only needs to be run once per session
font_add_google("Montserrat", "montserrat")
showtext_auto()
# --- Create a data frame for annotations for a cleaner plot ---
# This is more robust than multiple annotate() calls
annotation_data <- data.frame(
x = c(1, 2),
y = c(4.2, 4.2),
label = c("NS", "**")
)
# --- Create the plot ---
# Define the dodge position once to keep the code clean
dodge_pos <- position_dodge(width = 0.9)
ggplot(pred_sum, aes(x = species, y = mean, fill = treatment)) +
geom_bar(
stat = "identity",
position = dodge_pos,
colour = "grey20", # A softer outline than pure black
alpha = 0.9       # Slight transparency can look nice
) +
geom_errorbar(
aes(ymin = mean - ic, ymax = mean + ic),
width = 0.2,
position = dodge_pos,
linewidth = 0.5
) +
# Add annotation using our data frame
geom_text(
data = annotation_data,
aes(x = x, y = y, label = label),
inherit.aes = FALSE, # Stop it from inheriting the 'fill' aesthetic
size = 4,
family = "montserrat"
) +
# --- A professional, muted color palette ---
scale_fill_brewer(palette = "Set2") +
# --- Labels and Caption ---
labs(
x = "Species",
y = expression(Prey~Density~(m^2)),
fill = "Treatment",
caption = "Figure 1. Species impacts on prey density in experiment enclosures. n = 10 per treatment group (total = 40).\nError bars are 95% CIs. ** p<0.01"
) +
# --- A clean and professional theme ---
theme_bw(base_size = 12, base_family = "montserrat") + # Set base font size and family
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
axis.line = element_line(colour = "grey50"),
legend.position = "top", # Move legend to the top to save space
legend.title = element_text(face = "bold"),
plot.title.position = "plot", # Align title to the full plot
plot.caption.position = "plot", # Align caption to the full plot
plot.caption = element_text(hjust = 0, size = 10, color = "grey40")
)
library(magick)
# Read the plots
image1 <- image_read("Penguins.png")
image2 <- image_read("fish.png")
# Read your two photographs
# !!! IMPORTANT: Replace these paths with the actual file paths to your photos !!!
photo1 <- image_read("canal.jpg")
photo2 <- image_read("turnstones.jpg")
# Prepare the top row
# Scale each photo to be 800 pixels wide
# This avoids distorting the image.
image1_scaled <- image_crop(image1)
image2_scaled <- image_crop(image2)
# This avoids distorting the image.
photo1_scaled <- image_crop(photo1)
photo2_scaled <- image_crop(photo2)
# Prepare the bottom row
# Combine the two images side-by-side into a single image strip
top_row <- image_append(c(image1_scaled, image2_scaled))
# Combine the two scaled photos side-by-side into a single image strip
bottom_row <- image_append(c(photo1_scaled, photo2_scaled))
# Combine the top and bottom rows
# Stack the main plot on top of the bottom row image strip
final_cover <- image_append(c(top_row, bottom_row), stack = TRUE)
# Save the final composite image
# Write the final result to the file you want for your book cover
image_write(final_cover, path = "my-cover.png", format = "png")
image1_scaled <- image_crop(image1,"800")
image2_scaled <- image_crop(image2,"800")
# This avoids distorting the image.
photo1_scaled <- image_crop(photo1,"800")
photo2_scaled <- image_crop(photo2,"800")
# Prepare the bottom row
# Combine the two images side-by-side into a single image strip
top_row <- image_append(c(image1_scaled, image2_scaled))
# Combine the two scaled photos side-by-side into a single image strip
bottom_row <- image_append(c(photo1_scaled, photo2_scaled))
# Combine the top and bottom rows
# Stack the main plot on top of the bottom row image strip
final_cover <- image_append(c(top_row, bottom_row), stack = TRUE)
# Save the final composite image
# Write the final result to the file you want for your book cover
image_write(final_cover, path = "my-cover.png", format = "png")
image1 <- image_read("Penguins.png")
# --- Step 1: Load the magick library ---
library(magick)
# --- Step 2: Read in all four images ---
# Plot images
image1 <- image_read("Penguins.png")
image2 <- image_read("fish.png")
# Photographs
# Make sure these files are in your project folder or provide the full path
photo1 <- image_read("canal.jpg")
photo2 <- image_read("turnstones.jpg")
# --- Step 3: Prepare the images by cropping to a consistent size ---
# Define the target size for each panel in the grid.
# A 4:3 aspect ratio like 800x600 often looks good.
target_geometry <- "800x600+0+0"
# Crop each image to the target size from the center.
# The 'gravity = "center"' argument is key to getting the middle of each image.
image1_processed <- image_crop(image1, target_geometry, gravity = "center")
image2_processed <- image_crop(image2, target_geometry, gravity = "center")
photo1_processed <- image_crop(photo1, target_geometry, gravity = "center")
photo2_processed <- image_crop(photo2, target_geometry, gravity = "center")
# --- Step 4: Assemble the grid ---
# Combine the first two images side-by-side to create the top row
top_row <- image_append(c(image1_processed, image2_processed))
# Combine the next two images side-by-side to create the bottom row
bottom_row <- image_append(c(photo1_processed, photo2_processed))
# Stack the top and bottom rows vertically to create the final 2x2 grid
final_cover <- image_append(c(top_row, bottom_row), stack = TRUE)
# --- Step 5: Save the final composite image ---
image_write(final_cover, path = "my-cover.png", format = "png")
# Optional: Display the final image to check it
print(final_cover)
# --- Step 1: Load the magick library ---
library(magick)
# --- Step 2: Read in all four images ---
image1 <- image_read("Penguins.png")
image2 <- image_read("fish.png")
photo1 <- image_read("canal.jpg")
photo2 <- image_read("turnstones.jpg")
# --- Step 3: Use image_extent() to force all images to the same dimensions ---
# Define the target size for each panel.
target_geometry <- "800x600"
# This function intelligently resizes AND pads each image to fit the
# target dimensions, centering the content. This is the fix.
image1_processed <- image_extent(image1, target_geometry, gravity = "center", color = "white")
image2_processed <- image_extent(image2, target_geometry, gravity = "center", color = "white")
photo1_processed <- image_extent(photo1, target_geometry, gravity = "center", color = "white")
photo2_processed <- image_extent(photo2, target_geometry, gravity = "center", color = "white")
# --- Step 4: Assemble the grid (this logic remains the same) ---
# Combine the first two images to create the top row
top_row <- image_append(c(image1_processed, image2_processed))
# Combine the next two images to create the bottom row
bottom_row <- image_append(c(photo1_processed, photo2_processed))
# Stack the rows vertically to create the final 2x2 grid
final_cover <- image_append(c(top_row, bottom_row), stack = TRUE)
# --- Step 5: Save the final composite image ---
image_write(final_cover, path = "my-cover.png", format = "png")
# Optional: Display the final image to check it
print(final_cover)
# --- Step 1: Load the magick library ---
library(magick)
# --- Step 2: Read in all four images ---
image1 <- image_read("Penguins.png")
image2 <- image_read("fish.png")
photo1 <- image_read("canal.jpg")
photo2 <- image_read("turnstones.jpg")
# --- Step 3: Use image_extent() to force all images to the same dimensions ---
# Define the target size for each panel.
target_geometry <- "800x600"
# This function intelligently resizes AND pads each image to fit the
# target dimensions, centering the content. This is the fix.
image1_processed <- image_extent(image1, target_geometry, gravity = "center", color = "white")
image2_processed <- image_extent(image2, target_geometry, gravity = "center", color = "white")
photo1_processed <- image_extent(photo1, target_geometry, gravity = "center", color = "white")
photo2_processed <- image_extent(photo2, target_geometry, gravity = "center", color = "white")
# --- Step 4: Assemble the grid (this logic remains the same) ---
# Combine the first two images to create the top row
top_row <- image_append(c(image1_processed, image2_processed))
# Combine the next two images to create the bottom row
bottom_row <- image_append(c(photo1_processed, photo2_processed))
# Stack the rows vertically to create the final 2x2 grid
final_cover <- image_append(c(top_row, bottom_row), stack = TRUE)
# --- Step 5: Save the final composite image ---
image_write(final_cover, path = "my-cover.png", format = "png")
# Optional: Display the final image to check it
print(final_cover)
# --- Step 1: Load the magick library ---
library(magick)
# --- Step 2: Define our robust image processing function ---
# This function will take any image, trim its whitespace, scale it to fit
# inside the target dimensions, and then paste it onto a centered canvas.
process_image <- function(image, target_width = 800, target_height = 600) {
# 1. Trim all surrounding whitespace from the image
trimmed_image <- image_trim(image)
# 2. Scale the trimmed image to fit within the target dimensions
scaled_image <- image_scale(trimmed_image, paste0(target_width, "x", target_height))
# 3. Create a new, blank canvas of the exact target size
canvas <- image_blank(width = target_width, height = target_height, color = "white")
# 4. Composite (paste) the scaled image onto the center of the canvas
final_image <- image_composite(canvas, scaled_image, gravity = "center")
return(final_image)
}
# --- Step 3: Read and Process all four images using our function ---
image1 <- image_read("Penguins.png")
image2 <- image_read("fish.png")
photo1 <- image_read("canal.jpg")
photo2 <- image_read("turnstones.jpg")
# Apply our robust function to each image
image1_processed <- process_image(image1)
image2_processed <- process_image(image2)
photo1_processed <- process_image(photo1)
photo2_processed <- process_image(photo2)
# --- Step 4: Assemble the grid (this logic is the same) ---
# Combine the first two images to create the top row
top_row <- image_append(c(image1_processed, image2_processed))
# Combine the next two images to create the bottom row
bottom_row <- image_append(c(photo1_processed, photo2_processed))
# Stack the rows vertically to create the final 2x2 grid
final_cover <- image_append(c(top_row, bottom_row), stack = TRUE)
# --- Step 5: Save the final composite image ---
image_write(final_cover, path = "my-cover.png", format = "png")
# Optional: Display the final image to verify it worked
print(final_cover)
library(magick)
# --- Step 2: Define our robust image processing function ---
# This function will take any image, trim its whitespace, scale it to fit
# inside the target dimensions, and then paste it onto a centered canvas.
process_image <- function(image, target_width = 800, target_height = 800) {
# 1. Trim all surrounding whitespace from the image
trimmed_image <- image_trim(image)
# 2. Scale the trimmed image to fit within the target dimensions
scaled_image <- image_scale(trimmed_image, paste0(target_width, "x", target_height))
# 3. Create a new, blank canvas of the exact target size
canvas <- image_blank(width = target_width, height = target_height, color = "white")
# 4. Composite (paste) the scaled image onto the center of the canvas
final_image <- image_composite(canvas, scaled_image, gravity = "center")
return(final_image)
}
# --- Step 3: Read and Process all four images using our function ---
image1 <- image_read("Penguins.png")
image2 <- image_read("fish.png")
photo1 <- image_read("canal.jpg")
photo2 <- image_read("turnstones.jpg")
# Apply our robust function to each image
image1_processed <- process_image(image1)
image2_processed <- process_image(image2)
photo1_processed <- process_image(photo1)
photo2_processed <- process_image(photo2)
# --- Step 4: Assemble the grid (this logic is the same) ---
# Combine the first two images to create the top row
top_row <- image_append(c(image1_processed, image2_processed))
# Combine the next two images to create the bottom row
bottom_row <- image_append(c(photo1_processed, photo2_processed))
# Stack the rows vertically to create the final 2x2 grid
final_cover <- image_append(c(top_row, bottom_row), stack = TRUE)
# --- Step 5: Save the final composite image ---
image_write(final_cover, path = "my-cover.png", format = "png")
# Optional: Display the final image to verify it worked
print(final_cover)
