geom_point(colour = "darkblue",
alpha = 0.6) +
# This is the one-to- one line. If our RMSE was 0 all the points would sit on the line
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed", linewidth = 1) +
# this is our regression line. It sits close to the one-to-one line.....shows a good fit
geom_smooth(method = "lm",formula = 'y ~ x', se = FALSE, color = "blue") +
# Add labels and a title
labs(
title = "Model Predictions vs. Actual Observed Values",
x = "Predicted Richness",
y = "Observed Richness (Raw Data)"
) +
# Ensure the axes are scaled equally for a fair comparison
coord_equal() +
theme_bw()
# we will the predictions from the glmmTMB model not the corrected ones created by ggeffects as that is what performance used for the indices
RMSE_preds <- as.data.frame(predict(Final_M, type = "response")) %>%
rename(Predictions = 1) # Rename the first column to 'predictions'
# pull out the raw values using select()
Raw <- Benthic %>% dplyr::select("Richness")
# combine for ggplot....
df <- as.data.frame(cbind(RMSE_preds,Raw))
# we want to paste in the RMSE to the plot so we create the label
rmse_label <- paste("RMSE = 2.174")
ggplot(df, aes(x=Predictions, y=Richness)) +
geom_point(colour = "darkblue",
alpha = 0.6) +
# This is the one-to- one line. If our RMSE was 0 all the points would sit on the line
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed", linewidth = 1) +
# this is our regression line. It sits close to the one-to-one line.....shows a good fit
geom_smooth(method = "lm",formula = 'y ~ x', se = FALSE, color = "blue") +
# Add labels and a title
labs(
title = "Model Predictions vs. Actual Observed Values",
x = "Predicted Richness",
y = "Observed Richness (Raw Data)"
) +
# Ensure the axes are scaled equally for a fair comparison
coord_equal() +
theme_bw()
# we will the predictions from the glmmTMB model not the corrected ones created by ggeffects as that is what performance used for the indices
RMSE_preds <- as.data.frame(predict(Final_M, type = "response")) %>%
rename(Predictions = 1) # Rename the first column to 'predictions'
# pull out the raw values using select()
Raw <- Benthic %>% dplyr::select("Richness")
# combine for ggplot....
df <- as.data.frame(cbind(RMSE_preds,Raw))
# we want to paste in the RMSE to the plot so we create the label
rmse_label <- paste("RMSE = 2.174")
ggplot(df, aes(x=Predictions, y=Richness)) +
geom_point(colour = "darkblue",
alpha = 0.6) +
# This is the one-to- one line. If our RMSE was 0 all the points would sit on the line
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed", linewidth = 1) +
# this is our regression line. It sits close to the one-to-one line.....shows a good fit
geom_smooth(method = "lm",formula = 'y ~ x', se = FALSE, color = "blue") +
#Add the annotation of RMSE
annotate(
"text",
x = -Inf,      # Anchor to the far left
y = Inf,       # Anchor to the very top
label = rmse_label,
hjust = -0.2,  # Nudge it right from the left edge
vjust = 2,     # Nudge it down from the top edge
size = 5,
color = "black"
) +
# Add labels and a title
labs(
title = "Model Predictions vs. Actual Observed Values",
x = "Predicted Richness",
y = "Observed Richness"
) +
# Ensure the axes are scaled equally for a fair comparison
coord_equal() +
theme_bw()
# we will the predictions from the glmmTMB model not the corrected ones created by ggeffects as that is what performance used for the indices
RMSE_preds <- as.data.frame(predict(Final_M, type = "response")) %>%
rename(Predictions = 1) # Rename the first column to 'predictions'
# pull out the raw values using select()
Raw <- Benthic %>% dplyr::select("Richness")
# combine for ggplot....
df <- as.data.frame(cbind(RMSE_preds,Raw))
# we want to paste in the RMSE to the plot so we create the label
rmse_label <- paste("RMSE = 2.174")
ggplot(df, aes(x=Predictions, y=Richness)) +
geom_point(colour = "darkblue",
alpha = 0.6) +
# This is the one-to- one line. If our RMSE was 0 all the points would sit on the line
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed", linewidth = 1) +
# this is our regression line. It sits close to the one-to-one line.....shows a good fit
geom_smooth(method = "lm",formula = 'y ~ x', se = FALSE, color = "blue") +
#Add the annotation of RMSE
annotate(
"text",
x = -Inf,      # Anchor to the far left
y = Inf,       # Anchor to the very top
label = rmse_label,
hjust = -0.2,  # Nudge it right from the left edge
vjust = 2,     # Nudge it down from the top edge
size = 3,
color = "black"
) +
# Add labels and a title
labs(
title = "Model Predictions vs. Actual Observed Values",
x = "Predicted Richness",
y = "Observed Richness"
) +
# Ensure the axes are scaled equally for a fair comparison
coord_equal() +
theme_bw()
# we will the predictions from the glmmTMB model not the corrected ones created by ggeffects as that is what performance used for the indices
RMSE_preds <- as.data.frame(predict(Final_M, type = "response")) %>%
rename(Predictions = 1) # Rename the first column to 'predictions'
# pull out the raw values using select()
Raw <- Benthic %>% dplyr::select("Richness")
# combine for ggplot....
df <- as.data.frame(cbind(RMSE_preds,Raw))
# we want to paste in the RMSE to the plot so we create the label
rmse_label <- paste("RMSE = 2.174")
ggplot(df, aes(x=Predictions, y=Richness)) +
geom_point(colour = "darkblue",
alpha = 0.6) +
# This is the one-to- one line. If our RMSE was 0 all the points would sit on the line
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed", linewidth = 1) +
# this is our regression line. It sits close to the one-to-one line.....shows a good fit
geom_smooth(method = "lm",formula = 'y ~ x', se = FALSE, color = "blue") +
#Add the annotation of RMSE
annotate(
"text",
x = -Inf,      # Fix to the far left
y = Inf,       # Fix to the very top
label = rmse_label, # add label
hjust = -0.2,  # add spaces right from the left edge
vjust = 2,     # add spaces down from the top edge
size = 3,
color = "black"
) +
# Add labels and a title
labs(
title = "Model Predictions vs. Actual Observed Values",
x = "Predicted Richness",
y = "Observed Richness"
) +
# Ensure the axes are scaled equally for a fair comparison
coord_equal() +
theme_bw()
skim(Benthic)
# create predictions instead of plot them directly. Preds is dataframe not a graphics object
pred <- ggpredict(Final_M, terms = c("NAP", "fExp"))
# We need to rename the groups in the preds df otherwise we'll get two legends
pred$fExp <- pred$group
# plot
ggplot() +
geom_point(data = Benthic, aes(x = NAP, y = Richness, color = fExp), # raw data
alpha = 0.5, size = 2) +
geom_line(data = pred, aes(x = x, y = predicted, col = fExp), linewidth = 1) + # predictions
geom_ribbon(data = pred, aes(x = x, ymin = conf.low, ymax = conf.high, fill = fExp), # predictions
alpha = 0.2) + # add some labels etc
labs(x = "NAP", y = "Species richness", color = "Exposure", fill = "Exposure") +
theme_bw() # add a clean theme
#| label: mixed_model
#| echo: false
knitr::include_graphics("images/mixed_models_examples.png")
# interactive effects
p4 <- plot(ggeffects::ggpredict(Final_M, terms = c("NAP", "fExp"),bias_correction = TRUE))
p5 <- plot(ggeffects::ggpredict(Final_M, terms = c("NAP", "humus"),bias_correction = TRUE))
p4 / p5
#| label: mixed_model
#| echo: false
knitr::include_graphics("images/mixed_models_examples.png")
# List of packages
packages <- c("tidyverse", "ggfortify", "performance", "car", "skimr", "patchwork", "broom",
"ggeffects","MASS","MuMIn", "lme4","glmmTMB", "DHARMa")
# Load all packages and install the packages we have no previously installed on the system
lapply(packages, library, character.only = TRUE)
# SIMULATION PARAMETERS: Define the rules for our data
# Code generated by Gemini 2.0 - modified by JPS
# Use set.seed() to make our "random" data reproducible.
set.seed(42)
# Define the basic parameters for the experiment
n_groups <- 5      # Number of groups (e.g., 5 different individuals)
n_obs_per_group <- 11 # Number of observations per group (from X=0 to X=10)
x <- 0:10          # The predictor variable values
# Define the "fixed" or population-level effects (the thick black line)
pop_intercept <- 2.0  # The overall average intercept
pop_slope <- 0.5     # The overall average slope
residual_sd <- 0.8   # The random "noise" for each individual point
# Define the variance of the "random" effects
intercept_sd <- 2.0  # How much the group intercepts vary around the mean
slope_sd <- 0.8      # How much the group slopes vary (increased for more visual difference)
# --- DATA GENERATION: Create the two datasets ---
# First, generate the unique random effects for each of the 5 groups
random_intercepts <- rnorm(n_groups, mean = 0, sd = intercept_sd)
random_slopes <- rnorm(n_groups, mean = 0, sd = slope_sd)
# Generate the "Random Intercepts" dataset
data_ri <- map_df(1:n_groups, ~{
tibble(
group = as.character(.x),
x = x,
# Formula: y = (overall_intercept + group_specific_intercept) + (overall_slope * x) + error
y = (pop_intercept + random_intercepts[.x]) + (pop_slope * x) + rnorm(n_obs_per_group, 0, residual_sd),
model_type = "Random Intercepts Model"
)
})
# Generate the "Random Slopes and Intercepts" dataset
data_rs <- map_df(1:n_groups, ~{
tibble(
group = as.character(.x),
x = x,
# Formula: y = (overall_intercept + group_specific_intercept) + (overall_slope + group_specific_slope) * x + error
y = (pop_intercept + random_intercepts[.x]) + (pop_slope + random_slopes[.x]) * x + rnorm(n_obs_per_group, 0, residual_sd),
model_type = "Random Slopes + Intercepts Model"
)
})
# --- PLOTTING: Combine data and create the final figure ---
# Combine both datasets into a single data frame for plotting
full_data <- bind_rows(data_ri, data_rs)
# Create a small data frame to hold the annotation text and arrow coordinates
annotations <- tibble(
model_type = c("Random Intercepts Model", "Random Slopes + Intercepts Model"),
label = c("Groups differ\nin baseline (intercept)", "Groups differ in\nboth baseline & slope"),
x_arrow = c(0, 7),
y_arrow = c(10.5, 10.5),
x_text = c(0.5, 3),
y_text = c(11, 11),
x_arrow_end = c(0, 7),
y_arrow_end = c(5, 5)
)
# Create the final plot using ggplot2
ggplot(full_data, aes(x = x, y = y, color = group, group = group)) +
# Add the individual group lines (dashed and now fully opaque with alpha=1)
geom_line(linetype = "dashed", alpha = 1) +
# Add the individual data points (also fully opaque)
geom_point(alpha = 1) +
# Add the overall "fixed effect" or population-level line
geom_abline(intercept = pop_intercept, slope = pop_slope,
color = "black", linewidth = 1.5) +
# Add the arrows using the annotations data frame
geom_segment(
data = annotations,
aes(x = x_arrow, y = y_arrow, xend = x_arrow_end, yend = y_arrow_end),
arrow = arrow(length = unit(0.3, "cm")),
inherit.aes = FALSE # This prevents ggplot from trying to color the arrows
) +
# Add the text labels using the annotations data frame
geom_text(
data = annotations,
aes(x = x_text, y = y_text, label = label),
hjust = 0, vjust = 0,
inherit.aes = FALSE
) +
# Use facet_wrap to create the two side-by-side plots
facet_wrap(~ model_type) +
# --- Final aesthetic touches ---
scale_color_brewer(palette = "Set2") +
theme_bw() +
labs(x = "Predictor (X)", y = "Response (Y)") +
theme(
legend.position = "none", # Hide the legend as it's redundant
panel.grid.minor = element_blank(),
panel.grid.major = element_line(linetype = "dashed", color = "grey85"),
strip.background = element_blank(), # Remove facet title background
strip.text = element_text(face = "bold", size = 14), # Style facet titles
axis.title = element_text(size = 12)
)
Benthic <- read_csv("~/Documents/GitHub/Teaching/LM_25556Environmental_Analysis/Data/RIKZ.csv")
unique(Benthic$Exposure)
table(Benthic$Exposure)
# Code from Zuur et al. 2009.
Benthic <- Benthic |>
mutate(
# Convert 'Beach' to a factor. R will now know it's a grouping variable.
fbeach = as.factor(Beach),
fExp = case_when(
Exposure == 8 ~ 10,   # replace 8 with 10
TRUE ~ Exposure       # keep other values as is
),
fExp = factor(fExp, levels = c(10, 11)))
# JPS Code
table(Benthic$Exposure)
table(Benthic$fExp)
ggplot(Benthic, aes(x = factor(Beach), y = Richness)) +
geom_boxplot(
fill = "skyblue",
alpha = 0.7,
outlier.shape = NA # This tells the boxplot geom to NOT draw the outlier points.This important or it will plot all the datapoints and superimpose the outliers, creating too many points!
) +
# plot all points.
geom_jitter(
width = 0.2,
alpha = 0.5
) +
# Add labels and a clean theme
labs(x = "Beach", y = "Species Richness"
) +
theme_bw()
ggplot(Benthic, aes(x = NAP, y = Richness)) +
geom_point(alpha = 0.6) + # Added some transparency to the points
geom_smooth(
method = "lm",
se = TRUE, # add in some confidence interval
color = "red",       # Change line color to red
linewidth = 1.2,    # Make the line slightly thicker
formula = 'y ~ x',
) +
facet_wrap(
~ fbeach
) +
# Set the y-axis viewing window to start at 0. You cannot have a negative count of species richness.
coord_cartesian(ylim = c(0, NA)) +
theme_bw()
M1 <- beach.lm <- lm(Richness ~ NAP, data = Benthic)
summary(M1)
# Plot validation graph
op <- par(mfrow = c(2,2))
plot(M1)
par(op)
# strip out the residual
E <- residuals(M1) # straight standard residuals are okay  as it is a lm() model.
#plot against the NAP covariate
plot(Benthic$NAP, E)
plot(M1, which = 4)
# We could try to add a covariate in for beach as a form of ANCOVA
M2 <- lm(Richness ~ NAP * fbeach, data = Benthic)
summary(M2)
# Plot residual - it hasn't improved that either!
op <- par(mfrow = c(2,2))
plot(M2)
par(op)
# not much better....
E <- resid(M2)
op <- par(mfrow = c(1,2))
plot(E~Benthic$NAP,
xlab = "NAP",
ylab="Standard Residuals")
boxplot(E ~ Benthic$Beach,
xlab = "Beach",
ylab="Standard Residuals")
par(op)
# Reshape the data for plotting
# We select the response variable (Richness) and all the numerical predictors
# we want to plot against it.
benthic_long <- Benthic |>
# Select the columns of interest. We need dplyr::select because MASS is loaded as a library to avoid the conflict.
dplyr::select(
Richness,
NAP,
grainsize,
humus,
chalk,
sorting1
) |>
pivot_longer(
cols = -Richness,             # Pivot all columns EXCEPT Richness
names_to = "predictor_name",  # New column for the name of the predictors
values_to = "predictor_value" # New column for the value of the predictors
)
# Create the faceted scatterplot matrix
ggplot(benthic_long, aes(x = predictor_value, y = Richness)) +
#  plot points
geom_point(alpha = 0.6) +
# regression fit with CIs
geom_smooth(method = "lm", se = TRUE, color = "blue", formula = 'y ~ x') +
# LOESS smoother to check for non-linearity
geom_smooth(method = "loess", se = FALSE, color = "red", formula = 'y ~ x',
span = 1.2) + # span > 1 makes it less "wiggly"
# This creates a separate plot for each covariate.
facet_wrap(~ predictor_name, scales = "free_x") +
# Add labels and a title
labs(
title = "Species Richness vs. Environmental Predictors",
subtitle = "Comparing Linear Fit (Blue) to a LOESS Smoother (Red)",
x = "Predictor Value",
y = "Species Richness"
) +
# Change the theme, add blue facet header
theme_bw() +
theme(
strip.background = element_rect(fill = "lightblue")
)
# We are using the glmmTMB package to do this
# The default method here is REML so do not need to tell it to use REML.
M3 <- glmmTMB(Richness ~ NAP * fExp * humus  + (1 | fbeach),
data = Benthic, family = poisson)	# Random slope model
M4 <- glmmTMB(Richness ~ NAP * fExp * humus + (NAP | fbeach), family=poisson,
data = Benthic) # Random intercept and slope
aicM3 <- AIC(M3)
aicM4 <- AIC(M4)
AIC(M3,M4)
# Compare models with AIC
aicM4-aicM3 # difference is 3.254359
summary(M4)
# for reference library(MuMIn)
options(na.action=na.fail) # set options in Base R concerning missing values
summary(model.avg(dredge(M4), fit = TRUE, subset = TRUE), method = "ML")
options(na.action = "na.omit") # reset base R options
# Create the DHARMa simulation object
simulation_output <- simulateResiduals(fittedModel = Final_M)
# This one plot checks for multiple issues at once. Notice is the same as the base R function call
plot(simulation_output, rank=FALSE) # DHARMa ranks the residuals but this can obscure the real residual patterns, so we'll turn it off
# add tests for dispersion
# A significant p-value here means the dispersion is different from what's expected.
testDispersion(simulation_output)
# Test for outliers
# A significant p-value suggests the presence of more outliers than expected.
testOutliers(simulation_output)
# Plot validation graph
op <- par(mfrow = c(2, 2))
plotResiduals(simulation_output, form = Benthic$NAP, rank=FALSE)
plotResiduals(simulation_output, form = Benthic$fExp, rank=FALSE)
plotResiduals(simulation_output, form = Benthic$humus, rank=FALSE)
# Reset the plotting parameters
par(op)
summary(Final_M)
performance(Final_M)
# we will the predictions from the glmmTMB model not the corrected ones created by ggeffects as that is what performance used for the indices
RMSE_preds <- as.data.frame(predict(Final_M, type = "response")) %>%
rename(Predictions = 1) # Rename the first column to 'predictions'
# pull out the raw values using select()
Raw <- Benthic %>% dplyr::select("Richness")
# combine for ggplot....
df <- as.data.frame(cbind(RMSE_preds,Raw))
# we want to paste in the RMSE to the plot so we create the label
rmse_label <- paste("RMSE = 2.174")
ggplot(df, aes(x=Predictions, y=Richness)) +
geom_point(colour = "darkblue",
alpha = 0.6) +
# This is the one-to- one line. If our RMSE was 0 all the points would sit on the line
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed", linewidth = 1) +
# this is our regression line. It sits close to the one-to-one line.....shows a good fit
geom_smooth(method = "lm",formula = 'y ~ x', se = FALSE, color = "blue") +
#Add the annotation of RMSE
annotate(
"text",
x = -Inf,      # Fix to the far left
y = Inf,       # Fix to the very top
label = rmse_label, # add label
hjust = -0.2,  # add spaces right from the left edge
vjust = 2,     # add spaces down from the top edge
size = 3,
color = "black"
) +
# Add labels and a title
labs(
title = "Model Predictions vs. Actual Observed Values",
x = "Predicted Richness",
y = "Observed Richness"
) +
# Ensure the axes are scaled equally for a fair comparison
coord_equal() +
theme_bw()
# Uses library(ggeffects)
# single effects
# Effect of NAP
p1 <- plot(ggeffects::ggpredict(Final_M, terms = "NAP", bias_correction = TRUE))
# Effect of fExp
p2 <- plot(ggeffects::ggpredict(Final_M, terms = "fExp",bias_correction = TRUE))
# Effects of humus
p3 <- plot(ggeffects::ggpredict(Final_M, terms = "humus", bias_correction = TRUE))
# arrange using patchwork. Check the help file for examples of how to do this.
p1 + p2 / p3
# interactive effects
p4 <- plot(ggeffects::ggpredict(Final_M, terms = c("NAP", "fExp"),bias_correction = TRUE))
p5 <- plot(ggeffects::ggpredict(Final_M, terms = c("NAP", "humus"),bias_correction = TRUE))
p4 / p5
# create predictions instead of plot them directly. Preds is dataframe not a graphics object
pred <- ggpredict(Final_M, terms = c("NAP", "fExp"))
# We need to rename the groups in the preds df otherwise we'll get two legends
pred$fExp <- pred$group
# plot
ggplot() +
geom_point(data = Benthic, aes(x = NAP, y = Richness, color = fExp), # raw data
alpha = 0.5, size = 2) +
geom_line(data = pred, aes(x = x, y = predicted, col = fExp), linewidth = 1) + # predictions
geom_ribbon(data = pred, aes(x = x, ymin = conf.low, ymax = conf.high, fill = fExp), # predictions
alpha = 0.2) + # add some labels etc
labs(x = "NAP", y = "Species richness", color = "Exposure", fill = "Exposure") +
theme_bw() # add a clean theme
# Create the DHARMa simulation object
simulation_output <- simulateResiduals(fittedModel = Final_M)
# This one plot checks for multiple issues at once. Notice is the same as the base R function call
plot(simulation_output, rank=FALSE) # DHARMa ranks the residuals but this can obscure the real residual patterns, so we'll turn it off
# add tests for dispersion
# A significant p-value here means the dispersion is different from what's expected.
testDispersion(simulation_output)
# Create the DHARMa simulation object
simulation_output <- simulateResiduals(fittedModel = Final_M)
# This one plot checks for multiple issues at once. Notice is the same as the base R function call
plot(simulation_output, rank=FALSE) # DHARMa ranks the residuals but this can obscure the real residual patterns, so we'll turn it off
Final_M <- glmmTMB(Richness ~ NAP + humus + fExp + humus:NAP + (NAP | fbeach), family=poisson,
data = Benthic) # Random intercept and slope
# Create the DHARMa simulation object
simulation_output <- simulateResiduals(fittedModel = Final_M)
# This one plot checks for multiple issues at once. Notice is the same as the base R function call
plot(simulation_output, rank=FALSE) # DHARMa ranks the residuals but this can obscure the real residual patterns, so we'll turn it off
# add tests for dispersion
# A significant p-value here means the dispersion is different from what's expected.
testDispersion(simulation_output)
# Test for outliers
# A significant p-value suggests the presence of more outliers than expected.
testOutliers(simulation_output)
# Plot validation graph
op <- par(mfrow = c(2, 2))
plotResiduals(simulation_output, form = Benthic$NAP, rank=FALSE)
plotResiduals(simulation_output, form = Benthic$fExp, rank=FALSE)
plotResiduals(simulation_output, form = Benthic$humus, rank=FALSE)
# Reset the plotting parameters
par(op)
summary(Final_M)
summary(Final_M)
