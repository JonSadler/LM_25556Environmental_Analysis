# --- ADDED: Raw data points in the background ---
geom_point(data = road, aes(x = OPEN.L, y = TOT.N), alpha = 0.5) +
# --- Prediction line and ribbon on top ---
geom_line(data = partial_open_l, aes(x = OPEN.L, y = predicted), color = "blue", linewidth = 1) +
geom_ribbon(data = partial_open_l, aes(x = OPEN.L, ymin = lower_ci, ymax = upper_ci), alpha = 0.2, fill = "blue") +
labs(title = "Partial Effect of Open Land",
x = "Percentage of Open Land (OPEN.L)", y = "Predicted Road Kills") +
theme_minimal()
# ======================================================================
# Combine all plots into a grid
# ======================================================================
grid.arrange(p1, p2, p3, ncol = 2)
# List of packages
packages <- c("dplyr", "ggplot2","tidyverse", "moderndive",
"ggfortify", "performance", "car", "skimr", "gridExtra", "broom",
"ggeffects","MASS","MuMIn")
# Load all packages and install the packages we have no previously installed on the system
lapply(packages, library, character.only = TRUE)
# ======================================================================
# 1. Partial Effect for Distance to Park (D.PARK)
# ======================================================================
# Create a data frame where D.PARK varies and others are held at their mean
partial_d_park <- data.frame(
D.PARK = seq(min(road$D.PARK, na.rm = TRUE),
max(road$D.PARK, na.rm = TRUE), length.out = 100),
L.WAT.C = mean(road$L.WAT.C, na.rm = TRUE),
OPEN.L = mean(road$OPEN.L, na.rm = TRUE)
)
# Predict response and confidence intervals
predictions_d_park <- predict(road.final, newdata = partial_d_park, type = "response", se.fit = TRUE)
partial_d_park$predicted <- predictions_d_park$fit
partial_d_park$lower_ci <- predictions_d_park$fit - 1.96 * predictions_d_park$se.fit
partial_d_park$upper_ci <- predictions_d_park$fit + 1.96 * predictions_d_park$se.fit
# Plot 1
p1 <- ggplot() +
# --- ADDED: Raw data points in the background ---
geom_point(data = road, aes(x = D.PARK, y = TOT.N), alpha = 0.5) +
# --- Prediction line and ribbon on top ---
geom_line(data = partial_d_park, aes(x = D.PARK, y = predicted), color = "blue", linewidth = 1) +
geom_ribbon(data = partial_d_park, aes(x = D.PARK, ymin = lower_ci, ymax = upper_ci), alpha = 0.2, fill = "blue") +
labs(title = "Partial Effect of Distance to Park",
x = "Distance to Park (D.PARK)", y = "Predicted Road Kills") +
theme_minimal()
# ======================================================================
# 2. Partial Effect for Length of Water Course (L.WAT.C)
# ======================================================================
# Create a data frame where L.WAT.C varies and others are held at their mean
partial_l_wat_c <- data.frame(
L.WAT.C = seq(min(road$L.WAT.C, na.rm = TRUE),
max(road$L.WAT.C, na.rm = TRUE), length.out = 100),
D.PARK = mean(road$D.PARK, na.rm = TRUE),
OPEN.L = mean(road$OPEN.L, na.rm = TRUE)
)
# Predict and add columns
predictions_l_wat_c <- predict(road.final, newdata = partial_l_wat_c, type = "response", se.fit = TRUE)
partial_l_wat_c$predicted <- predictions_l_wat_c$fit
partial_l_wat_c$lower_ci <- predictions_l_wat_c$fit - 1.96 * predictions_l_wat_c$se.fit
partial_l_wat_c$upper_ci <- predictions_l_wat_c$fit + 1.96 * predictions_l_wat_c$se.fit
# Plot 2
p2 <- ggplot() +
# --- ADDED: Raw data points in the background ---
geom_point(data = road, aes(x = L.WAT.C, y = TOT.N), alpha = 0.5) +
# --- Prediction line and ribbon on top ---
geom_line(data = partial_l_wat_c, aes(x = L.WAT.C, y = predicted), color = "blue", linewidth = 1) +
geom_ribbon(data = partial_l_wat_c, aes(x = L.WAT.C, ymin = lower_ci, ymax = upper_ci), alpha = 0.2, fill = "blue") +
labs(title = "Partial Effect of Water Course Length",
x = "Length of Water Course (L.WAT.C)", y = "Predicted Road Kills") +
theme_minimal()
# ======================================================================
# 3. Partial Effect for Open Land (OPEN.L)
# ======================================================================
# Create a data frame where OPEN.L varies and others are held at their mean
partial_open_l <- data.frame(
OPEN.L = seq(min(road$OPEN.L, na.rm = TRUE),
max(road$OPEN.L, na.rm = TRUE), length.out = 100),
D.PARK = mean(road$D.PARK, na.rm = TRUE),
L.WAT.C = mean(road$L.WAT.C, na.rm = TRUE)
)
# Predict and add columns
predictions_open_l <- predict(road.final, newdata = partial_open_l, type = "response", se.fit = TRUE)
partial_open_l$predicted <- predictions_open_l$fit
partial_open_l$lower_ci <- predictions_open_l$fit - 1.96 * predictions_open_l$se.fit
partial_open_l$upper_ci <- predictions_open_l$fit + 1.96 * predictions_open_l$se.fit
# Plot 3
p3 <- ggplot() +
# --- ADDED: Raw data points in the background ---
geom_point(data = road, aes(x = OPEN.L, y = TOT.N), alpha = 0.5) +
# --- Prediction line and ribbon on top ---
geom_line(data = partial_open_l, aes(x = OPEN.L, y = predicted), color = "blue", linewidth = 1) +
geom_ribbon(data = partial_open_l, aes(x = OPEN.L, ymin = lower_ci, ymax = upper_ci), alpha = 0.2, fill = "blue") +
labs(title = "Partial Effect of Open Land",
x = "Percentage of Open Land (OPEN.L)", y = "Predicted Road Kills") +
theme_minimal()
# ======================================================================
# Combine all plots into a grid
# ======================================================================
grid.arrange(p1, p2, p3, ncol = 2)
scatterplotMatrix(~Srich
+ Latitude + Elevation,
diag = list(method = "qqplot"),
regLine = list(col = "blue", lwd = 2),   # Linear regression line in blue
smooth = list(col.smooth = "blue", lty.smooth = 2, lwd.smooth = 2), # Loess in blue, dashed
data = gotelli)
skim(gotelli)
glimpse(road)
checks <- skim(road) # create tibble (a form dataframe created by dplyr)
checks
options(na.action=na.fail) # set options in Base R concerning missing values
summary(model.avg(dredge(gotelli.glm), fit = TRUE, subset = TRUE))
options(na.action = "na.omit") # reset base R options
setwd("~/Documents/GitHub/Teaching/LM_25556Environmental_Analysis/Codefiles/LM25556ModuleHandbook")
# Get the log-likelihood of your full model
logLik_full <- logLik(road.final)
# To get the log-likelihood of the null model, we need to fit it first.
# The null model has only an intercept (e.g., Srich ~ 1).
model_null <- update(road.final, . ~ 1)
logLik_null <- logLik(model_null)
# Apply the formula and convert the final result to a simple number
r2_mcfadden <- as.numeric(1 - (logLik_full / logLik_null))
# Print the result - it will now be a clean number
print(r2_mcfadden)
# [1] 0.1564486
# Get the log-likelihood of your full model
logLik_full <- logLik(road.final)
# To get the log-likelihood of the null model, we need to fit it first.
# The null model has only an intercept (e.g., Srich ~ 1).
model_null <- update(road.final, . ~ 1)
logLik_null <- logLik(model_null)
# Apply the formula and convert the final result to a simple number
r2_mcfadden <- as.numeric(1 - (logLik_full / logLik_null))
# Print the result - it will now be a clean number
print(r2_mcfadden)
# [1] 0.1564486
tidy(road.final, exponentiate = TRUE)
print(r2(road.final))
gvif_values <- performance::check_collinearity(road.glm)
print(gvif_values)
ggplot(eda, aes(x = value, y = TOT.N)) +
# Layer 1: The scatter plot points
geom_point(alpha = 0.6) +
# Layer 2: The linear regression fit for each plot
# se = TRUE for the linear model
geom_smooth(method = "lm", se = TRUE, color = "blue", formula = 'y ~ x') +
# we add a smoother to compare against the linear plot
geom_smooth(method = "loess", se = FALSE, color = "red", formula = 'y ~ x',
span = 1.2) +
# This creates a separate plot for each of the X-variables.
facet_wrap(~ variables, scales = "free") +
# Add labels and a title
labs(
title = "Total kills (TOT.N) v Explanatory Variables",
x = "Explanatory Variables",
y = "Total Road Kill per Sector of Road"
) +
# Change the theme
theme_bw() +
theme(
strip.background = element_rect(fill = "lightblue") # Adds stip labels as the facet titles, in lightblue
)
str(road)
R <- resid(road.final, type='pearson') # extract the pearson residuals
op <- par(mfrow = c(2, 2))
plot(road$OPEN.L~R)
plot(road$L.WAT.C~R)
plot(road$D.PARK~R)
par(op)
check_overdispersion(road.glm)
autoplot(road.glm, method="glm")
## plot simulated residuals
autoplot(road.glm1, method="glm")
autoplot(road.nb, method="glm.nb")
op <- par(mfrow = c(2, 2))
plot(road.nb) # no patterns....
par(op)
autoplot(road.nb, method="glm.nb")
options(na.action=na.fail) # set options in Base R concerning missing values
summary(model.avg(dredge(road.nb), fit = TRUE, subset = TRUE))
options(na.action = "na.omit") # reset base R options
road.final <- glm.nb(TOT.N ~ D.PARK + L.WAT.C + OPEN.L, data=road)
summary(road.final)
op <- par(mfrow = c(2, 2))
plot(road.final) # no patterns....
par(op)
# ======================================================================
# 1. Partial Effect for Distance to Park (D.PARK)
# ======================================================================
# Create a data frame where D.PARK varies and others are held at their mean
partial_d_park <- data.frame(
D.PARK = seq(min(road$D.PARK, na.rm = TRUE),
max(road$D.PARK, na.rm = TRUE), length.out = 100),
L.WAT.C = mean(road$L.WAT.C, na.rm = TRUE),
OPEN.L = mean(road$OPEN.L, na.rm = TRUE)
)
# Predict response and confidence intervals
predictions_d_park <- predict(road.final, newdata = partial_d_park, type = "response", se.fit = TRUE)
partial_d_park$predicted <- predictions_d_park$fit
partial_d_park$lower_ci <- predictions_d_park$fit - 1.96 * predictions_d_park$se.fit
partial_d_park$upper_ci <- predictions_d_park$fit + 1.96 * predictions_d_park$se.fit
# Plot 1
p1 <- ggplot() +
# --- ADDED: Raw data points in the background ---
geom_point(data = road, aes(x = D.PARK, y = TOT.N), alpha = 0.5) +
# --- Prediction line and ribbon on top ---
geom_line(data = partial_d_park, aes(x = D.PARK, y = predicted), color = "blue", linewidth = 1) +
geom_ribbon(data = partial_d_park, aes(x = D.PARK, ymin = lower_ci, ymax = upper_ci), alpha = 0.2, fill = "blue") +
labs(title = "Partial Effect of Distance to Park",
x = "Distance to Park (D.PARK)", y = "Predicted Road Kills") +
theme_minimal()
# ======================================================================
# 2. Partial Effect for Length of Water Course (L.WAT.C)
# ======================================================================
# Create a data frame where L.WAT.C varies and others are held at their mean
partial_l_wat_c <- data.frame(
L.WAT.C = seq(min(road$L.WAT.C, na.rm = TRUE),
max(road$L.WAT.C, na.rm = TRUE), length.out = 100),
D.PARK = mean(road$D.PARK, na.rm = TRUE),
OPEN.L = mean(road$OPEN.L, na.rm = TRUE)
)
# Predict and add columns
predictions_l_wat_c <- predict(road.final, newdata = partial_l_wat_c, type = "response", se.fit = TRUE)
partial_l_wat_c$predicted <- predictions_l_wat_c$fit
partial_l_wat_c$lower_ci <- predictions_l_wat_c$fit - 1.96 * predictions_l_wat_c$se.fit
partial_l_wat_c$upper_ci <- predictions_l_wat_c$fit + 1.96 * predictions_l_wat_c$se.fit
# Plot 2
p2 <- ggplot() +
# --- ADDED: Raw data points in the background ---
geom_point(data = road, aes(x = L.WAT.C, y = TOT.N), alpha = 0.5) +
# --- Prediction line and ribbon on top ---
geom_line(data = partial_l_wat_c, aes(x = L.WAT.C, y = predicted), color = "blue", linewidth = 1) +
geom_ribbon(data = partial_l_wat_c, aes(x = L.WAT.C, ymin = lower_ci, ymax = upper_ci), alpha = 0.2, fill = "blue") +
labs(title = "Partial Effect of Water Course Length",
x = "Length of Water Course (L.WAT.C)", y = "Predicted Road Kills") +
theme_minimal()
# ======================================================================
# 3. Partial Effect for Open Land (OPEN.L)
# ======================================================================
# Create a data frame where OPEN.L varies and others are held at their mean
partial_open_l <- data.frame(
OPEN.L = seq(min(road$OPEN.L, na.rm = TRUE),
max(road$OPEN.L, na.rm = TRUE), length.out = 100),
D.PARK = mean(road$D.PARK, na.rm = TRUE),
L.WAT.C = mean(road$L.WAT.C, na.rm = TRUE)
)
# Predict and add columns
predictions_open_l <- predict(road.final, newdata = partial_open_l, type = "response", se.fit = TRUE)
partial_open_l$predicted <- predictions_open_l$fit
partial_open_l$lower_ci <- predictions_open_l$fit - 1.96 * predictions_open_l$se.fit
partial_open_l$upper_ci <- predictions_open_l$fit + 1.96 * predictions_open_l$se.fit
# Plot 3
p3 <- ggplot() +
# --- ADDED: Raw data points in the background ---
geom_point(data = road, aes(x = OPEN.L, y = TOT.N), alpha = 0.5) +
# --- Prediction line and ribbon on top ---
geom_line(data = partial_open_l, aes(x = OPEN.L, y = predicted), color = "blue", linewidth = 1) +
geom_ribbon(data = partial_open_l, aes(x = OPEN.L, ymin = lower_ci, ymax = upper_ci), alpha = 0.2, fill = "blue") +
labs(title = "Partial Effect of Open Land",
x = "Percentage of Open Land (OPEN.L)", y = "Predicted Road Kills") +
theme_minimal()
# ======================================================================
# Combine all plots into a grid
# ======================================================================
grid.arrange(p1, p2, p3, ncol = 2)
# boxplot
ggplot(gotelli, aes(x=as.factor(Habitat), y=Srich)) +
geom_boxplot() +
theme_bw() +
theme(
panel.grid.minor = element_blank(), #remove the minor grids
panel.grid.major = element_blank(), #remove the minor grids
)
gotelli.glm <- glm(Srich ~ as.factor(Habitat) + Latitude + Elevation,
family = poisson, data  = gotelli)
gvif_values <- performance::check_collinearity(gotelli.glm)
print(gvif_values)
gotelli <- gotelli %>%
mutate(
cLatitude  = as.numeric(scale(Latitude,  center = TRUE, scale = TRUE)),
cElevation = as.numeric(scale(Elevation, center = TRUE, scale = TRUE))
)
gotelli.glm <- glm(Srich ~ as.factor(Habitat) * cLatitude * cElevation,
family = poisson, data  = gotelli)
summary(gotelli.glm)
null_deviance <- gotelli.glm$null.deviance #
residual_deviance <- gotelli.glm$deviance
proportion_explained <- (null_deviance - residual_deviance) / null_deviance
# Print result
cat("Proportion of Deviance Explained:", proportion_explained, "\n")
check_overdispersion(gotelli.glm)
dispersion_stat <- sum(residuals(gotelli.glm, type = "pearson")^2) / gotelli.glm$df.residual
cat("Dispersion Statistic:", dispersion_stat, "\n")
options(na.action=na.fail) # set options in Base R concerning missing values
summary(model.avg(dredge(gotelli.glm), fit = TRUE, subset = TRUE))
options(na.action = "na.omit") # reset base R options
gotelli.glm <- glm(Srich ~ as.factor(Habitat) + cLatitude + cElevation,
family=poisson, data = gotelli)
summary(gotelli.glm)
## simulate residuals
autoplot(gotelli.glm, method="glm")
## plot simulated residuals
plot(gotelli.glm, which=4)
pres <- residuals.glm(gotelli.glm, type="pearson") # strip the residuals
#plot against the predictor variables in a panel plot
par(mfrow = c(2, 2))  # Set 3 rows and 2 columns
plot(pres ~ gotelli$cLatitude)
plot(pres ~ gotelli$cElevation)
boxplot(pres ~ as.factor(gotelli$Habitat))
#par(mfrow = c(1, 1)) # set default graphics back
pres <- residuals.glm(gotelli.glm, type="pearson") # strip the residuals
#plot against the predictor variables in a panel plot
par(mfrow = c(2, 2))  # Set 3 rows and 2 columns
plot(pres ~ gotelli$cLatitude)
plot(pres ~ gotelli$cElevation)
boxplot(pres ~ as.factor(gotelli$Habitat))
par(mfrow = c(1, 1)) # set default graphics back
tidy(gotelli.glm, exponentiate = TRUE)
# Ensure your categorical variable is a factor
gotelli$Habitat <- as.factor(gotelli$Habitat)
# Calculate the mean and sd directly from the RAW data columns in our gotelli dataframe
lat_center <- mean(gotelli$Latitude, na.rm = TRUE)
lat_scale  <- sd(gotelli$Latitude, na.rm = TRUE)
elev_mean  <- mean(gotelli$Elevation, na.rm = TRUE)
elev_center <- mean(gotelli$Elevation, na.rm = TRUE)
elev_scale  <- sd(gotelli$Elevation, na.rm = TRUE)
# Create a grid of predictor values for the plot
prediction_grid <- expand.grid(
Latitude = seq(42, 45, length.out = 100),
Habitat = levels(gotelli$Habitat), # it is essential the variable is a factor not a character class
Elevation = elev_mean
)
# Transform the grid to match the model's predictors
prediction_grid_transformed <- prediction_grid |>
mutate(
cLatitude = (Latitude - lat_center) / lat_scale,
cElevation = (Elevation - elev_center) / elev_scale
)
# Generate predictions
predictions <- predict(gotelli.glm,
newdata = prediction_grid_transformed,
type = "response", # this command exponentiates the logged values back to their measured state.
se.fit = TRUE)
# Combine everything into a final, clean prediction data frame
predictions_df <- cbind(prediction_grid,
predicted_Srich = predictions$fit,
se = predictions$se.fit) |>
mutate(
lwr = predicted_Srich - 1.96 * se,
upr = predicted_Srich + 1.96 * se
)
# Create the plot
# Notice that the first layer now uses our initial 'gotelli' data frame.
ggplot() +
# Layer 1: The raw data points from the 'gotelli' data frame
geom_point(data = gotelli, aes(x = Latitude, y = Srich, shape = Habitat), size = 2.5) +
# Layer 2 & 3: The predictions (from the new 'predictions_df')
geom_ribbon(data = predictions_df,
aes(x = Latitude, ymin = lwr, ymax = upr, fill = Habitat),
alpha = 0.2) +
geom_line(data = predictions_df,
aes(x = Latitude, y = predicted_Srich, color = Habitat),
linewidth = 1) +
# code for scales, labse)
scale_color_manual(values = c("Forest" = "black", "Bog" = "black")) +
scale_fill_manual(values = c("Forest" = "gray50", "Bog" = "gray50")) +
scale_shape_manual(values = c("Forest" = 16, "Bog" = 21)) +
labs(
title = "A Comparison of Global Ant Species Richness in Forest / Bog Habitats and Latitude",
x = "Latitude",
y = "Ant Species Richness"
) +
theme_bw() +
theme(
legend.position = "top",
legend.justification = "right",
legend.box.background = element_rect(color = "white")
)
glimpse(road)
checks <- skim(road) # create tibble (a form dataframe created by dplyr)
checks
# Select only the columns you want to plot
# We need TOT.N (our response) plus all the desired X-variables (possible explanatories)
eda <- road %>%
dplyr::select(
TOT.N, BufoCalamita, S.RICH, OPEN.L, OLIVE, MONT.S, MONT,
POLIC, SHRUB, URBAN, WAT.RES, L.WAT.C, L.D.ROAD, L.P.ROAD,
D.WAT.RES, D.WAT.COUR, D.PARK, N.PATCH, P.EDGE, L.SDI
) %>%
pivot_longer(
cols = -c(TOT.N, BufoCalamita, S.RICH),             # Pivot all columns EXCEPT TOT.N,BufoCalamita,S.RICH
names_to = "variables",    # New column for the name of the X-predictor
values_to = "value"       # New column for the value of the X-predictor
)
# Select only the columns you want to plot
# We need TOT.N (our response) plus all the desired X-variables (possible explanatories)
eda <- road %>%
dplyr::select(
TOT.N, BufoCalamita, S.RICH, OPEN.L, OLIVE, MONT.S, MONT,
POLIC, SHRUB, URBAN, WAT.RES, L.WAT.C, L.D.ROAD, L.P.ROAD,
D.WAT.RES, D.WAT.COUR, D.PARK, N.PATCH, P.EDGE, L.SDI
) %>%
pivot_longer(
cols = -c(TOT.N, BufoCalamita, S.RICH),             # Pivot all columns EXCEPT TOT.N,BufoCalamita,S.RICH
names_to = "variables",    # New column for the name of the X-predictor
values_to = "value"       # New column for the value of the X-predictor
)
ggplot(eda, aes(sample = value)) +
stat_qq() +
stat_qq_line(col="red") +
facet_wrap(~ variables, scales = "free")
ggplot(road, aes(sample = TOT.N)) +
geom_qq(color = "black", shape = 1) + # shape = 1 gives open circles
# This line shows where the points *should* fall if the data were perfectly normal.
geom_qq_line(color = "blue", linewidth = 1)
road.glm <- glm(TOT.N ~ OPEN.L + SHRUB + WAT.RES + L.WAT.C + L.P.ROAD +
D.WAT.COUR + D.PARK,family=poisson,data=road)
summary(road.glm)
gvif_values <- performance::check_collinearity(road.glm)
print(gvif_values)
check_overdispersion(road.glm)
plot(road.glm, which =4)
summary(road.nb)
options(na.action=na.fail) # set options in Base R concerning missing values
summary(model.avg(dredge(road.nb), fit = TRUE, subset = TRUE))
options(na.action = "na.omit") # reset base R options
road.final <- glm.nb(TOT.N ~ D.PARK + L.WAT.C + OPEN.L, data=road)
summary(road.final)
# ======================================================================
# 1. Partial Effect for Distance to Park (D.PARK)
# ======================================================================
# Create a data frame where D.PARK varies and others are held at their mean
partial_d_park <- data.frame(
D.PARK = seq(min(road$D.PARK, na.rm = TRUE),
max(road$D.PARK, na.rm = TRUE), length.out = 100),
L.WAT.C = mean(road$L.WAT.C, na.rm = TRUE),
OPEN.L = mean(road$OPEN.L, na.rm = TRUE)
)
# Predict response and confidence intervals
predictions_d_park <- predict(road.final, newdata = partial_d_park, type = "response", se.fit = TRUE)
partial_d_park$predicted <- predictions_d_park$fit
partial_d_park$lower_ci <- predictions_d_park$fit - 1.96 * predictions_d_park$se.fit
partial_d_park$upper_ci <- predictions_d_park$fit + 1.96 * predictions_d_park$se.fit
# Plot 1
p1 <- ggplot() +
# --- ADDED: Raw data points in the background ---
geom_point(data = road, aes(x = D.PARK, y = TOT.N), alpha = 0.5) +
# --- Prediction line and ribbon on top ---
geom_line(data = partial_d_park, aes(x = D.PARK, y = predicted), color = "blue", linewidth = 1) +
geom_ribbon(data = partial_d_park, aes(x = D.PARK, ymin = lower_ci, ymax = upper_ci), alpha = 0.2, fill = "blue") +
labs(title = "Partial Effect of Distance to Park",
x = "Distance to Park (D.PARK)", y = "Predicted Road Kills") +
theme_minimal()
# ======================================================================
# 2. Partial Effect for Length of Water Course (L.WAT.C)
# ======================================================================
# Create a data frame where L.WAT.C varies and others are held at their mean
partial_l_wat_c <- data.frame(
L.WAT.C = seq(min(road$L.WAT.C, na.rm = TRUE),
max(road$L.WAT.C, na.rm = TRUE), length.out = 100),
D.PARK = mean(road$D.PARK, na.rm = TRUE),
OPEN.L = mean(road$OPEN.L, na.rm = TRUE)
)
# Predict and add columns
predictions_l_wat_c <- predict(road.final, newdata = partial_l_wat_c, type = "response", se.fit = TRUE)
partial_l_wat_c$predicted <- predictions_l_wat_c$fit
partial_l_wat_c$lower_ci <- predictions_l_wat_c$fit - 1.96 * predictions_l_wat_c$se.fit
partial_l_wat_c$upper_ci <- predictions_l_wat_c$fit + 1.96 * predictions_l_wat_c$se.fit
# Plot 2
p2 <- ggplot() +
# --- ADDED: Raw data points in the background ---
geom_point(data = road, aes(x = L.WAT.C, y = TOT.N), alpha = 0.5) +
# --- Prediction line and ribbon on top ---
geom_line(data = partial_l_wat_c, aes(x = L.WAT.C, y = predicted), color = "blue", linewidth = 1) +
geom_ribbon(data = partial_l_wat_c, aes(x = L.WAT.C, ymin = lower_ci, ymax = upper_ci), alpha = 0.2, fill = "blue") +
labs(title = "Partial Effect of Water Course Length",
x = "Length of Water Course (L.WAT.C)", y = "Predicted Road Kills") +
theme_minimal()
# ======================================================================
# 3. Partial Effect for Open Land (OPEN.L)
# ======================================================================
# Create a data frame where OPEN.L varies and others are held at their mean
partial_open_l <- data.frame(
OPEN.L = seq(min(road$OPEN.L, na.rm = TRUE),
max(road$OPEN.L, na.rm = TRUE), length.out = 100),
D.PARK = mean(road$D.PARK, na.rm = TRUE),
L.WAT.C = mean(road$L.WAT.C, na.rm = TRUE)
)
# Predict and add columns
predictions_open_l <- predict(road.final, newdata = partial_open_l, type = "response", se.fit = TRUE)
partial_open_l$predicted <- predictions_open_l$fit
partial_open_l$lower_ci <- predictions_open_l$fit - 1.96 * predictions_open_l$se.fit
partial_open_l$upper_ci <- predictions_open_l$fit + 1.96 * predictions_open_l$se.fit
# Plot 3
p3 <- ggplot() +
# --- ADDED: Raw data points in the background ---
geom_point(data = road, aes(x = OPEN.L, y = TOT.N), alpha = 0.5) +
# --- Prediction line and ribbon on top ---
geom_line(data = partial_open_l, aes(x = OPEN.L, y = predicted), color = "blue", linewidth = 1) +
geom_ribbon(data = partial_open_l, aes(x = OPEN.L, ymin = lower_ci, ymax = upper_ci), alpha = 0.2, fill = "blue") +
labs(title = "Partial Effect of Open Land",
x = "Percentage of Open Land (OPEN.L)", y = "Predicted Road Kills") +
theme_minimal()
# ======================================================================
# Combine all plots into a grid
# ======================================================================
grid.arrange(p1, p2, p3, ncol = 2)
# Select only the predictors from your final model
predictors <- road |> select(D.PARK, L.WAT.C, OPEN.L)
# Select only the predictors from your final model
predictors <- road |> dplyr::select(D.PARK, L.WAT.C, OPEN.L)
# Check the correlation matrix
cor(predictors, use = "complete.obs")
tidy(road.final, exponentiate = TRUE)
print(r2(road.final))
