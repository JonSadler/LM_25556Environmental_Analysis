lapply(packages, library, character.only = TRUE)
# --- SIMULATION PARAMETERS: Define the rules for our data ---
# Code generated by Gemini 2.0 - modified by JPS
# Use set.seed() to make our "random" data reproducible.
set.seed(42)
# Define the basic parameters for the experiment
n_groups <- 5      # Number of groups (e.g., 5 different individuals)
n_obs_per_group <- 11 # Number of observations per group (from X=0 to X=10)
x <- 0:10          # The predictor variable values
# Define the "fixed" or population-level effects (the thick black line)
pop_intercept <- 2.0  # The overall average intercept
pop_slope <- 0.5     # The overall average slope
residual_sd <- 0.8   # The random "noise" for each individual point
# Define the variance of the "random" effects
intercept_sd <- 2.0  # How much the group intercepts vary around the mean
slope_sd <- 0.8      # How much the group slopes vary (increased for more visual difference)
# --- DATA GENERATION: Create the two datasets ---
# First, generate the unique random effects for each of the 5 groups
random_intercepts <- rnorm(n_groups, mean = 0, sd = intercept_sd)
random_slopes <- rnorm(n_groups, mean = 0, sd = slope_sd)
# Generate the "Random Intercepts" dataset
data_ri <- map_df(1:n_groups, ~{
tibble(
group = as.character(.x),
x = x,
# Formula: y = (overall_intercept + group_specific_intercept) + (overall_slope * x) + error
y = (pop_intercept + random_intercepts[.x]) + (pop_slope * x) + rnorm(n_obs_per_group, 0, residual_sd),
model_type = "Random Intercepts Model"
)
})
# Generate the "Random Slopes and Intercepts" dataset
data_rs <- map_df(1:n_groups, ~{
tibble(
group = as.character(.x),
x = x,
# Formula: y = (overall_intercept + group_specific_intercept) + (overall_slope + group_specific_slope) * x + error
y = (pop_intercept + random_intercepts[.x]) + (pop_slope + random_slopes[.x]) * x + rnorm(n_obs_per_group, 0, residual_sd),
model_type = "Random Slopes + Intercepts Model"
)
})
# --- PLOTTING: Combine data and create the final figure ---
# Combine both datasets into a single data frame for plotting
full_data <- bind_rows(data_ri, data_rs)
# Create a small data frame to hold the annotation text and arrow coordinates
annotations <- tibble(
model_type = c("Random Intercepts Model", "Random Slopes + Intercepts Model"),
label = c("Groups differ\nin baseline (intercept)", "Groups differ in\nboth baseline & slope"),
x_arrow = c(0, 7),
y_arrow = c(10.5, 10.5),
x_text = c(0.5, 3),
y_text = c(11, 11),
x_arrow_end = c(0, 7),
y_arrow_end = c(5, 5)
)
# Create the final plot using ggplot2
ggplot(full_data, aes(x = x, y = y, color = group, group = group)) +
# Add the individual group lines (dashed and now fully opaque with alpha=1)
geom_line(linetype = "dashed", alpha = 1) +
# Add the individual data points (also fully opaque)
geom_point(alpha = 1) +
# Add the overall "fixed effect" or population-level line
geom_abline(intercept = pop_intercept, slope = pop_slope,
color = "black", linewidth = 1.5) +
# Add the arrows using the annotations data frame
geom_segment(
data = annotations,
aes(x = x_arrow, y = y_arrow, xend = x_arrow_end, yend = y_arrow_end),
arrow = arrow(length = unit(0.3, "cm")),
inherit.aes = FALSE # This prevents ggplot from trying to color the arrows
) +
# Add the text labels using the annotations data frame
geom_text(
data = annotations,
aes(x = x_text, y = y_text, label = label),
hjust = 0, vjust = 0,
inherit.aes = FALSE
) +
# Use facet_wrap to create the two side-by-side plots
facet_wrap(~ model_type) +
# --- Final aesthetic touches ---
scale_color_brewer(palette = "Set2") +
theme_bw() +
labs(x = "Predictor (X)", y = "Response (Y)") +
theme(
legend.position = "none", # Hide the legend as it's redundant
panel.grid.minor = element_blank(),
panel.grid.major = element_line(linetype = "dashed", color = "grey85"),
strip.background = element_blank(), # Remove facet title background
strip.text = element_text(face = "bold", size = 14), # Style facet titles
axis.title = element_text(size = 12)
)
Benthic <- read_csv("~/Documents/GitHub/Teaching/LM_25556Environmental_Analysis/Data/RIKZ.csv")
unique(Benthic$Exposure)
table(Benthic$Exposure)
# Code from Zuur et al. 2009.
Benthic <- Benthic |>
mutate(
# Convert 'Beach' to a factor. R will now know it's a grouping variable.
fbeach = as.factor(Beach),
fExp = case_when(
Exposure == 8 ~ 10,   # replace 8 with 10
TRUE ~ Exposure       # keep other values as is
),
fExp = factor(fExp, levels = c(10, 11)))
# JPS Code
table(Benthic$Exposure)
table(Benthic$fExp)
ggplot(Benthic, aes(x = NAP, y = Richness)) +
geom_point(alpha = 0.6) + # Added some transparency to the points
geom_smooth(
method = "lm",
se = TRUE, # add in some confidence interval
color = "red",       # Change line color to red
linewidth = 1.2,    # Make the line slightly thicker
formula = 'y ~ x',
) +
facet_wrap(
~ fbeach
) +
# Set the y-axis viewing window to start at 0. You cannot have a negative count of species richness.
coord_cartesian(ylim = c(0, NA)) +
theme_bw()
M1 <- beach.lm <- lm(Richness ~ NAP, data = Benthic)
summary(M1)
# Plot validation graph
op <- par(mfrow = c(2,2))
plot(M1)
par(op)
# strip out the residual
E <- residuals(M1) # straight standard residuals are okay  as it is a lm() model.
#plot against the NAP covariate
plot(Benthic$NAP, E)
plot(M1, which = 4)
# We could try to add a covariate in for beach as a form of ANCOVA
M2 <- lm(Richness ~ NAP * fbeach, data = Benthic)
summary(M2)
# Plot residual - it hasn't improved that either!
op <- par(mfrow = c(2,2))
plot(M2)
par(op)
# not much better....
E <- resid(M2)
op <- par(mfrow = c(1,2))
plot(E~Benthic$NAP,
xlab = "NAP",
ylab="Standard Residuals")
boxplot(E ~ Benthic$Beach,
xlab = "Beach",
ylab="Standard Residuals")
par(op)
# Reshape the data for plotting
# We select the response variable (Richness) and all the numerical predictors
# we want to plot against it.
benthic_long <- Benthic |>
# Select the columns of interest. We need dplyr::select because MASS is loaded as a library to avoid the conflict.
dplyr::select(
Richness,
NAP,
grainsize,
humus,
chalk,
sorting1
) |>
pivot_longer(
cols = -Richness,             # Pivot all columns EXCEPT Richness
names_to = "predictor_name",  # New column for the name of the predictors
values_to = "predictor_value" # New column for the value of the predictors
)
# Create the faceted scatterplot matrix
ggplot(benthic_long, aes(x = predictor_value, y = Richness)) +
# Layer 1: The scatter plot points
geom_point(alpha = 0.6) +
# Layer 2: The linear regression fit with its confidence interval
geom_smooth(method = "lm", se = TRUE, color = "blue", formula = 'y ~ x') +
# Layer 3: The LOESS smoother to check for non-linearity
geom_smooth(method = "loess", se = FALSE, color = "red", formula = 'y ~ x',
span = 1.2) + # span > 1 makes it less "wiggly"
# Layer 4: This creates a separate plot for each of the predictor variables.
facet_wrap(~ predictor_name, scales = "free_x") +
# Add labels and a title
labs(
title = "Species Richness vs. Environmental Predictors",
subtitle = "Comparing Linear Fit (Blue) to a LOESS Smoother (Red)",
x = "Predictor Value",
y = "Species Richness"
) +
# Change the theme, add blue facet header
theme_bw() +
theme(
strip.background = element_rect(fill = "lightblue")
)
# We are using the glmmTMB package to do this
# The default method here is REML so do not need to tell it to use REML.
M3 <- glmmTMB(Richness ~ NAP * fExp * humus  + (1 | fbeach),
data = Benthic, family = poisson)	# Random slope model
M4 <- glmmTMB(Richness ~ NAP * fExp * humus + (NAP | fbeach), family=poisson,
data = Benthic) # Random intercept and slope
aicM3 <- AIC(M3)
aicM4 <- AIC(M4)
AIC(M3,M4)
# Compare models with AIC
aicM4-aicM3
summary(M3)
# for reference library(MuMIn)
options(na.action=na.fail) # set options in Base R concerning missing values
summary(model.avg(dredge(M3), fit = TRUE, subset = TRUE), method = "ML")
options(na.action = "na.omit") # reset base R options
Final_M <- glmmTMB(Richness ~ fExp + humus + NAP  + humus: NAP + (1 | fbeach), data = Benthic, family = poisson)
performance(Final_M)
check_outliers(Final_M)
# Create the DHARMa simulation object
simulation_output <- simulateResiduals(fittedModel = Final_M)
# This one plot checks for multiple issues at once. Notice is the same as the base R function call
plot(simulation_output)
# add tests for dispersion
# A significant p-value here means the dispersion is different from what's expected.
testDispersion(simulation_output)
# Test for outliers
# A significant p-value suggests the presence of more outliers than expected.
testOutliers(simulation_output)
# Plot validation graph
op <- par(mfrow = c(2, 2))
plotResiduals(simulation_output, form = Benthic$NAP)
plotResiduals(simulation_output, form = Benthic$fExp)
plotResiduals(simulation_output, form = Benthic$humus)
# Reset the plotting parameters
par(op)
# boxplot of the errant factor fExp
ggplot(Benthic, aes(fExp, Richness)) +
geom_boxplot(fill = "lightblue", outlier.shape = NA) +
geom_point(alpha = 0.5) +
theme_bw()
table(Benthic$fExp, Benthic$Richness)
ggplot(Benthic, aes(x = NAP, y = Richness, colour = fExp)) + # colour plots lines for each level of the fExp factor.
geom_point(alpha = 0.6, size = 2) +
geom_smooth(method = "lm", se = FALSE, formula = 'y ~ x', linewidth = 1.1) +
labs(
x = "NAP (continuous variable)",
y = "Species richness",
colour = "Exposure level"
) +
theme_classic()
compois_M <- glmmTMB(Richness ~ fExp + humus + NAP  + humus: NAP + (1 | fbeach), data = Benthic, family = compois, dispformula = ~NAP * fExp)
# Create the DHARMa simulation object
simulation_output <- simulateResiduals(fittedModel = compois_M)
# This one plot checks for multiple issues at once. Notice is the same as the base R function call
plot(simulation_output, rank=FALSE) # we have turned off the ranking here so we see the true patterns of the residuals
testDispersion(simulation_output)
testOutliers(simulation_output)
plotResiduals(simulation_output, form = Benthic$fExp, rank=FALSE)
summary(compois_M)
# Uses library(ggeffects)
# single effects
# Effect of NAP
p1 <- plot(ggeffects::ggpredict(compois_M, terms = "NAP"))
# Effect of fExp
p2 <- plot(ggeffects::ggpredict(compois_M, terms = "fExp"))
# Effects of humus
p3 <- plot(ggeffects::ggpredict(compois_M, terms = "humus"))
# arrange using patchwork. Check the help file for examples of how to do this.
p1 + p2 / p3
# interactive effects
p4 <- plot(ggeffects::ggpredict(compois_M, terms = c("NAP", "fExp")))
p5 <- plot(ggeffects::ggpredict(compois_M, terms = c("NAP", "humus")))
p4 / p5
# create predictions instead of plot them directly. Preds is dataframe not a graphics object
pred <- ggpredict(compois_M, terms = c("NAP", "fExp"))
# We need to rename the groups in the preds df otherwise we'll get two legends
pred$fExp <- pred$group
# The key thing here is that we use two dataframes, the raw data (Benthic) for the points and the predictions (preds) for the regression lines and CIs
ggplot() +
geom_point(data = Benthic, aes(x = NAP, y = Richness, color = fExp), # raw data
alpha = 0.5, size = 2) +
geom_line(data = pred, aes(x = x, y = predicted, col = fExp), linewidth = 1) + # predictions
geom_ribbon(data = pred, aes(x = x, ymin = conf.low, ymax = conf.high, fill = fExp), # predictions
alpha = 0.2) + # add some labels etc
labs(x = "NAP", y = "Species richness", color = "Exposure", fill = "Exposure") +
theme_bw() # add a clean theme
# Code from Zuur et al. 2009.
Benthic <- Benthic |>
mutate(
# Convert 'Beach' to a factor. R will now know it's a grouping variable.
fbeach = as.factor(Beach),
fExp = case_when(
Exposure == 8 ~ 10,   # replace 8 with 10
TRUE ~ Exposure       # keep other values as is
),
fExp = factor(fExp, levels = c(10, 11)))
# JPS Code
table(Benthic$Exposure)
table(Benthic$fExp)
ggplot(Benthic, aes(x = factor(Beach), y = Richness)) +
geom_boxplot(
fill = "skyblue",
alpha = 0.7,
outlier.shape = NA # This tells the boxplot geom to NOT draw the outlier points.This important or it will plot all the datapoints and superimpose the outliers, creating too many points!
) +
# plot all points.
geom_jitter(
width = 0.2,
alpha = 0.5
) +
# Add labels and a clean theme
labs(x = "Beach", y = "Species Richness"
) +
theme_bw()
ggplot(Benthic, aes(x = NAP, y = Richness)) +
geom_point(alpha = 0.6) + # Added some transparency to the points
geom_smooth(
method = "lm",
se = TRUE, # add in some confidence interval
color = "red",       # Change line color to red
linewidth = 1.2,    # Make the line slightly thicker
formula = 'y ~ x',
) +
facet_wrap(
~ fbeach
) +
# Set the y-axis viewing window to start at 0. You cannot have a negative count of species richness.
coord_cartesian(ylim = c(0, NA)) +
theme_bw()
M1 <- beach.lm <- lm(Richness ~ NAP, data = Benthic)
summary(M1)
# Plot validation graph
op <- par(mfrow = c(2,2))
plot(M1)
par(op)
# strip out the residual
E <- residuals(M1) # straight standard residuals are okay  as it is a lm() model.
#plot against the NAP covariate
plot(Benthic$NAP, E)
plot(M1, which = 4)
# We could try to add a covariate in for beach as a form of ANCOVA
M2 <- lm(Richness ~ NAP * fbeach, data = Benthic)
summary(M2)
# Plot residual - it hasn't improved that either!
op <- par(mfrow = c(2,2))
plot(M2)
par(op)
# not much better....
E <- resid(M2)
op <- par(mfrow = c(1,2))
plot(E~Benthic$NAP,
xlab = "NAP",
ylab="Standard Residuals")
boxplot(E ~ Benthic$Beach,
xlab = "Beach",
ylab="Standard Residuals")
par(op)
# Reshape the data for plotting
# We select the response variable (Richness) and all the numerical predictors
# we want to plot against it.
benthic_long <- Benthic |>
# Select the columns of interest. We need dplyr::select because MASS is loaded as a library to avoid the conflict.
dplyr::select(
Richness,
NAP,
grainsize,
humus,
chalk,
sorting1
) |>
pivot_longer(
cols = -Richness,             # Pivot all columns EXCEPT Richness
names_to = "predictor_name",  # New column for the name of the predictors
values_to = "predictor_value" # New column for the value of the predictors
)
# Create the faceted scatterplot matrix
ggplot(benthic_long, aes(x = predictor_value, y = Richness)) +
# Layer 1: The scatter plot points
geom_point(alpha = 0.6) +
# Layer 2: The linear regression fit with its confidence interval
geom_smooth(method = "lm", se = TRUE, color = "blue", formula = 'y ~ x') +
# Layer 3: The LOESS smoother to check for non-linearity
geom_smooth(method = "loess", se = FALSE, color = "red", formula = 'y ~ x',
span = 1.2) + # span > 1 makes it less "wiggly"
# Layer 4: This creates a separate plot for each of the predictor variables.
facet_wrap(~ predictor_name, scales = "free_x") +
# Add labels and a title
labs(
title = "Species Richness vs. Environmental Predictors",
subtitle = "Comparing Linear Fit (Blue) to a LOESS Smoother (Red)",
x = "Predictor Value",
y = "Species Richness"
) +
# Change the theme, add blue facet header
theme_bw() +
theme(
strip.background = element_rect(fill = "lightblue")
)
# Reshape the data for plotting
# We select the response variable (Richness) and all the numerical predictors
# we want to plot against it.
benthic_long <- Benthic |>
# Select the columns of interest. We need dplyr::select because MASS is loaded as a library to avoid the conflict.
dplyr::select(
Richness,
NAP,
grainsize,
humus,
chalk,
sorting1
) |>
pivot_longer(
cols = -Richness,             # Pivot all columns EXCEPT Richness
names_to = "predictor_name",  # New column for the name of the predictors
values_to = "predictor_value" # New column for the value of the predictors
)
# Create the faceted scatterplot matrix
ggplot(benthic_long, aes(x = predictor_value, y = Richness)) +
#  plot points
geom_point(alpha = 0.6) +
# regression fit with CIs
geom_smooth(method = "lm", se = TRUE, color = "blue", formula = 'y ~ x') +
# LOESS smoother to check for non-linearity
geom_smooth(method = "loess", se = FALSE, color = "red", formula = 'y ~ x',
span = 1.2) + # span > 1 makes it less "wiggly"
# This creates a separate plot for each covariate.
facet_wrap(~ predictor_name, scales = "free_x") +
# Add labels and a title
labs(
title = "Species Richness vs. Environmental Predictors",
subtitle = "Comparing Linear Fit (Blue) to a LOESS Smoother (Red)",
x = "Predictor Value",
y = "Species Richness"
) +
# Change the theme, add blue facet header
theme_bw() +
theme(
strip.background = element_rect(fill = "lightblue")
)
# We are using the glmmTMB package to do this
# The default method here is REML so do not need to tell it to use REML.
M3 <- glmmTMB(Richness ~ NAP * fExp * humus  + (1 | fbeach),
data = Benthic, family = poisson)	# Random slope model
M4 <- glmmTMB(Richness ~ NAP * fExp * humus + (NAP | fbeach), family=poisson,
data = Benthic) # Random intercept and slope
aicM3 <- AIC(M3)
aicM4 <- AIC(M4)
AIC(M3,M4)
# Compare models with AIC
aicM4-aicM3
summary(M3)
# for reference library(MuMIn)
options(na.action=na.fail) # set options in Base R concerning missing values
summary(model.avg(dredge(M3), fit = TRUE, subset = TRUE), method = "ML")
options(na.action = "na.omit") # reset base R options
Final_M <- glmmTMB(Richness ~ fExp + humus + NAP  + humus: NAP + (1 | fbeach), data = Benthic, family = poisson)
performance(Final_M)
check_outliers(Final_M)
# Create the DHARMa simulation object
simulation_output <- simulateResiduals(fittedModel = Final_M)
# This one plot checks for multiple issues at once. Notice is the same as the base R function call
plot(simulation_output)
# Plot validation graph
op <- par(mfrow = c(2, 2))
plotResiduals(simulation_output, form = Benthic$NAP)
plotResiduals(simulation_output, form = Benthic$fExp)
plotResiduals(simulation_output, form = Benthic$humus)
# Reset the plotting parameters
par(op)
# boxplot of the errant factor fExp
ggplot(Benthic, aes(fExp, Richness)) +
geom_boxplot(fill = "lightblue", outlier.shape = NA) +
geom_point(alpha = 0.5) +
theme_bw()
table(Benthic$fExp, Benthic$Richness)
ggplot(Benthic, aes(x = NAP, y = Richness, colour = fExp)) + # colour plots lines for each level of the fExp factor.
geom_point(alpha = 0.6, size = 2) +
geom_smooth(method = "lm", se = FALSE, formula = 'y ~ x', linewidth = 1.1) +
labs(
x = "NAP (continuous variable)",
y = "Species richness",
colour = "Exposure level"
) +
theme_classic()
compois_M <- glmmTMB(Richness ~ fExp + humus + NAP  + humus: NAP + (1 | fbeach), data = Benthic, family = compois, dispformula = ~NAP * fExp)
# Create the DHARMa simulation object
simulation_output <- simulateResiduals(fittedModel = compois_M)
# This one plot checks for multiple issues at once. Notice is the same as the base R function call
plot(simulation_output, rank=FALSE) # we have turned off the ranking here so we see the true patterns of the residuals
testDispersion(simulation_output)
testOutliers(simulation_output)
plotResiduals(simulation_output, form = Benthic$fExp, rank=FALSE)
summary(compois_M)
# Uses library(ggeffects)
# single effects
# Effect of NAP
p1 <- plot(ggeffects::ggpredict(compois_M, terms = "NAP"))
# Effect of fExp
p2 <- plot(ggeffects::ggpredict(compois_M, terms = "fExp"))
# Effects of humus
p3 <- plot(ggeffects::ggpredict(compois_M, terms = "humus"))
# arrange using patchwork. Check the help file for examples of how to do this.
p1 + p2 / p3
# interactive effects
p4 <- plot(ggeffects::ggpredict(compois_M, terms = c("NAP", "fExp")))
p5 <- plot(ggeffects::ggpredict(compois_M, terms = c("NAP", "humus")))
p4 / p5
# create predictions instead of plot them directly. Preds is dataframe not a graphics object
pred <- ggpredict(compois_M, terms = c("NAP", "fExp"))
# We need to rename the groups in the preds df otherwise we'll get two legends
pred$fExp <- pred$group
# The key thing here is that we use two dataframes, the raw data (Benthic) for the points and the predictions (preds) for the regression lines and CIs
ggplot() +
geom_point(data = Benthic, aes(x = NAP, y = Richness, color = fExp), # raw data
alpha = 0.5, size = 2) +
geom_line(data = pred, aes(x = x, y = predicted, col = fExp), linewidth = 1) + # predictions
geom_ribbon(data = pred, aes(x = x, ymin = conf.low, ymax = conf.high, fill = fExp), # predictions
alpha = 0.2) + # add some labels etc
labs(x = "NAP", y = "Species richness", color = "Exposure", fill = "Exposure") +
theme_bw() # add a clean theme
